

---

# ğŸ› ï¸ GestiÃ³n de la ConfiguraciÃ³n (GCS)

> 1. Defina gestiÃ³n de la configuraciÃ³n. Explique por quÃ© es necesario.

## ğŸ“– DefiniciÃ³n

La **GestiÃ³n de la ConfiguraciÃ³n de Software (GCS)** es el arte de **identificar, organizar, revisar y controlar** todos los cambios que se hacen en el software que construye un equipo.  
Es un conjunto de actividades que comienza cuando inicia un proyecto de software y termina cuando el software deja de usarse.

Su objetivo es **hacer el trabajo mÃ¡s fÃ¡cil**, **evitar errores** y **mantener el orden** en el proyecto.

## â“ Â¿Por quÃ© es necesaria?

La GestiÃ³n de la ConfiguraciÃ³n es necesaria para:

- ğŸ“¦ **Identificar** todos los elementos que forman el software (cÃ³digo, documentos, datos).
- ğŸ”„ **Administrar los cambios** de manera controlada, evitando que el proyecto se convierta en un caos.
- ğŸ› ï¸ **Facilitar la creaciÃ³n de diferentes versiones** del software.
- âœ… **Asegurar la calidad** del software a medida que se realizan cambios.
- ğŸ§© **Rastrear y analizar** todos los cambios hechos en el proyecto.
- ğŸ“¢ **Informar a todo el equipo** sobre quÃ© cambios se hicieron y cuÃ¡ndo.

Sin una buena gestiÃ³n de la configuraciÃ³n, los proyectos podrÃ­an:

- Volverse desorganizados,
- Perder calidad,
- Retrasarse en las entregas.


## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estÃ¡s construyendo un **castillo de Legos** con tus amigos.  
La **GestiÃ³n de la ConfiguraciÃ³n** serÃ­a como tener un **encargado** que:

- ğŸ“‹ **Sabe quÃ© piezas** tiene el castillo (quÃ© Legos usaron).
- âœï¸ **Anota quiÃ©n puso quÃ© bloque** y **cuÃ¡ndo**.
- ğŸ“š **Cuida las instrucciones** y se asegura de que todos sepan quÃ© parte estÃ¡n construyendo.
- ğŸ—ï¸ Si alguien quiere **cambiar algo** (por ejemplo, hacer una torre mÃ¡s alta), el encargado:
  - Se asegura de que **todos estÃ©n de acuerdo**,
  - Verifica que el cambio **no destruya** otra parte del castillo.

AsÃ­, el castillo se construye de forma ordenada, **sin romperse** y **sin hacer lÃ­o**.

### ğŸ¯ Resumen

La GCS es como tener un jefe de los Legos que cuida que todo estÃ© ordenado y seguro mientras construimos un gran castillo entre todos.


---

# ğŸ› ï¸ Diferencia entre Mantenimiento y GestiÃ³n de la ConfiguraciÃ³n (GCS)

## â“ Â¿Por quÃ© **mantenimiento** no es lo mismo que **GCS**?

La **GestiÃ³n de la ConfiguraciÃ³n (GCS)** y el **mantenimiento** son actividades distintas dentro del ciclo de vida del software:

## ğŸ› ï¸ Mantenimiento de Software

- Es un **conjunto de actividades** que ocurren **despuÃ©s** de que el software se entrega al cliente y comienza a usarse.
- Incluye:
  - ğŸ”§ **Arreglar errores** encontrados en el uso real.
  - ğŸŒŸ **Hacer pequeÃ±as mejoras** o adaptaciones.
- En metodologÃ­as Ã¡giles, el mantenimiento puede hacerse de manera **continua**, no como una etapa aparte.


## ğŸ“¦ GestiÃ³n de la ConfiguraciÃ³n de Software (GCS)

- Es un conjunto de actividades que **empieza cuando el proyecto comienza** y **termina cuando el software deja de usarse**.
- Se encarga de:
  - ğŸ—‚ï¸ **Organizar y controlar** todos los cambios en el software.
  - ğŸ§© **Identificar versiones** de cada parte del software.
  - ğŸ•µï¸ **Seguir el rastro** de quÃ© cambios se hicieron, cuÃ¡ndo y por quÃ©.


## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estÃ¡s construyendo un **castillo de Legos**:

- ğŸ° **Mantenimiento**:
  - Es cuando **ya terminaste** el castillo,
  - EstÃ¡s jugando con Ã©l,
  - Y de repente una **torre se rompe** o quieres ponerle una **bandera nueva**.
  - Entonces lo **arreglas** o le haces mejoras.
  - Esto pasa **despuÃ©s** de que el castillo estÃ¡ listo.

- ğŸ“‹ **GestiÃ³n de la ConfiguraciÃ³n (GCS)**:
  - Es como tener un **encargado** que:
    - **Desde el principio** te ayuda a construir,
    - **Anota** quÃ© piezas usaste,
    - **Controla** si cambiaste algo,
    - Y **se asegura** de que todo estÃ© bien armado.
  - EstÃ¡ **todo el tiempo**: mientras construyes, cuando terminas, y cuando arreglas algo.
  - No aparece solo cuando el castillo ya estÃ¡ roto, **estÃ¡ desde el primer momento**.

### ğŸ¯ Resumen

- El **mantenimiento** empieza **despuÃ©s** de que el software estÃ¡ entregado.
- La **GCS** trabaja **durante todo el proyecto**, desde el primer dÃ­a hasta el Ãºltimo.

---
# ğŸ§© Â¿QuÃ© es un Artefacto de Software?

## DefiniciÃ³n

Un **artefacto de software** es **cualquier cosa que se crea** durante la construcciÃ³n de un programa de computadora.

Son como las **piezas** y **documentos** necesarios para construir el software y entender cÃ³mo funciona.

## ğŸ“‹ Ejemplos de artefactos de software

- ğŸ“„ Documentos con las **ideas** o **requisitos** de lo que debe hacer el programa.
- ğŸ¨ **Dibujos** o **diagramas** de cÃ³mo se verÃ¡ el programa.
- ğŸ§‘â€ğŸ’» **CÃ³digo fuente**: instrucciones escritas para que la computadora entienda quÃ© hacer.
- ğŸ§ª **Pruebas** (tests) para asegurarse de que el programa funciona bien.
- ğŸ“š **Manuales** de uso para que las personas sepan cÃ³mo usar el programa.


## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estÃ¡s construyendo un **castillo de Legos**. Los artefactos de software serÃ­an:

- âœï¸ El **dibujo** que hiciste de cÃ³mo querÃ­as que fuera el castillo.
- ğŸ§± La **caja** con todas las piezas de Lego.
- ğŸ“œ Las **instrucciones** que te dicen cÃ³mo encajar las piezas.
- ğŸšª Probar si la **puerta** del castillo se abre y se cierra bien.
- ğŸ“ Un **papel** donde escribes para tu amigo cÃ³mo construiste una torre, para que Ã©l tambiÃ©n pueda hacer una igual.

Todas estas cosas (el dibujo, las piezas, las instrucciones, las pruebas y las notas) son **artefactos**: son **todo lo que creaste o usaste** mientras hacÃ­as tu castillo.

### ğŸ¯ Resumen

Un artefacto de software es **todo lo que produces** mientras haces un programa: documentos, dibujos, cÃ³digo, pruebas, instrucciones y mÃ¡s.

---

# ğŸ”„ Diferencias entre VersiÃ³n, RevisiÃ³n y Variante

## ğŸ“– Conceptos

- **VersiÃ³n**:  
  Es una **instancia especÃ­fica** de un artefacto de software, distinta de otras instancias.  
  â¡ï¸ *Ejemplo*: La **versiÃ³n 1.0** de un juego.

- **RevisiÃ³n**:  
  Es una **nueva versiÃ³n** que **corrige o mejora** versiones anteriores.  
  â¡ï¸ *Ejemplo*: La **versiÃ³n 1.1** del juego corrige errores encontrados en la 1.0.  
  â¡ï¸ *Otro ejemplo*: **Windows 7** es una revisiÃ³n de **Windows Vista**.

- **Variante**:  
  Es una **versiÃ³n alternativa** que **agrega funciones o caracterÃ­sticas**, pero **no reemplaza** a las versiones anteriores.  
  â¡ï¸ *Ejemplo*: Una versiÃ³n "**Pro**" de un programa que tiene mÃ¡s funciones que la versiÃ³n bÃ¡sica.


## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estÃ¡s dibujando un **sol**:

- ğŸŒ **VersiÃ³n**:  
  Haces un dibujo de un sol amarillo con 8 rayitos.  
  Luego haces otro dibujo de un sol naranja con 10 rayitos.  
  â¡ï¸ Â¡Son dos versiones diferentes de tu sol!

- ğŸ› ï¸ **RevisiÃ³n**:  
  Ves que en tu primer dibujo algunos rayitos quedaron chuecos.  
  Los borras y los dibujas mÃ¡s derechos.  
  â¡ï¸ Eso es una revisiÃ³n: **arreglaste** tu sol para que quede mejor.

- ğŸ˜ **Variante**:  
  Agarras tu sol amarillo y le dibujas unas **gafas de sol**.  
  â¡ï¸ Â¡Ahora tu sol tiene algo nuevo!  
  Es una variante: **aÃ±adiste algo extra** sin borrar tu dibujo original.


### ğŸ¯ Resumen Final

| Concepto  | QuÃ© es                                                   | Ejemplo                       |
|-----------|-----------------------------------------------------------|-------------------------------|
| VersiÃ³n   | Un artefacto en un momento dado.                           | Juego versiÃ³n 1.0             |
| RevisiÃ³n  | Una correcciÃ³n o mejora de una versiÃ³n anterior.           | Juego versiÃ³n 1.1 (corrige errores) |
| Variante  | Una versiÃ³n alternativa que agrega caracterÃ­sticas nuevas. | VersiÃ³n "Pro" de un programa   |

---


# ğŸ” Trazabilidad entre dos Ãtems de ConfiguraciÃ³n (IC)

## ğŸ“– Concepto

La **trazabilidad** entre dos Ãtems de ConfiguraciÃ³n (IC) es la **capacidad de identificar y seguir la conexiÃ³n** entre dos elementos distintos que forman parte de un sistema de software.

Un **Ãtem de ConfiguraciÃ³n** (IC) puede ser:
- Un documento de requisitos
- Un fragmento de cÃ³digo
- Un diseÃ±o de interfaz
- Una prueba, entre otros.

La trazabilidad permite:
- Ver **quÃ© elemento depende de otro**.
- Entender **por quÃ© existe** un elemento.
- Saber **quÃ© impacto** tiene cambiar algo.

## ğŸ¯ Ejemplo

- **Requisito (IC 1):**  
  "El usuario debe poder hacer clic en un botÃ³n que diga 'Guardar'".

- **CÃ³digo (IC 2):**  
  El fragmento de cÃ³digo que crea el botÃ³n "Guardar" y guarda la informaciÃ³n cuando se hace clic.

**La trazabilidad** es la **relaciÃ³n directa** entre:
- El requisito que pide el botÃ³n.
- Y el cÃ³digo que implementa el botÃ³n.

AsÃ­, si maÃ±ana se cambia el requisito (por ejemplo, que el botÃ³n diga "Enviar" en lugar de "Guardar"), **sabemos exactamente quÃ© cÃ³digo tenemos que modificar**.

## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que construyes un castillo de Legos:

- ğŸ“œ **InstrucciÃ³n (IC 1):**  
  "Pon un bloque rojo encima de la torre mÃ¡s alta".

- ğŸ§± **AcciÃ³n (IC 2):**  
  Colocas un bloque rojo en la torre mÃ¡s alta.

**La trazabilidad** es **saber que ese bloque rojo estÃ¡ ahÃ­** porque **una instrucciÃ³n** te dijo que lo pusieras.

â¡ï¸ Si la torre se cae o si quieren cambiar el color del bloque, sabes **exactamente cuÃ¡l instrucciÃ³n seguir** para arreglarlo o modificarlo.


### ğŸ¯ Resumen RÃ¡pido

| Concepto                   | QuÃ© es                                      | Ejemplo                                |
| -------------------------- | ------------------------------------------- | -------------------------------------- |
| Ãtem de ConfiguraciÃ³n (IC) | Cualquier elemento importante del software. | Requisito, cÃ³digo, diseÃ±o, prueba      |
| Trazabilidad               | Saber cÃ³mo un IC se relaciona con otro IC.  | Requisito del botÃ³n â†” CÃ³digo del botÃ³n |


---

# ğŸ¨ Control del Cambio en la GCS: Â¿Sigue vigente la definiciÃ³n de Pressman?

## ğŸ“– DefiniciÃ³n tradicional segÃºn Pressman

Dentro de la GestiÃ³n de la ConfiguraciÃ³n del Software (GCS), **Pressman** definiÃ³ el control como:

> "La bÃºsqueda del equilibrio entre creatividad y caos".

Esta idea reflejaba la tensiÃ³n clÃ¡sica en el desarrollo de software entre:
- La **creatividad** necesaria para innovar y crear nuevas soluciones.
- El **caos** que surge cuando los cambios no se controlan adecuadamente.

## ğŸ”„ VisiÃ³n actual del control del cambio

Hoy en dÃ­a, con el auge de las **metodologÃ­as Ã¡giles**, la visiÃ³n sobre el control del cambio ha evolucionado:

- **Ya no se trata de creatividad vs. caos**, sino de **gestionar mÃºltiples fuentes de creatividad** de manera organizada.
- **El cambio es constante** y se fomenta su incorporaciÃ³n temprana y frecuente, en lugar de temerle.
- **Herramientas modernas** (control de versiones, integraciÃ³n continua, automatizaciÃ³n de pruebas) permiten gestionar cambios **sin generar caos**.

ğŸ“ˆ **La curva de Boehm** enseÃ±aba que el costo del cambio aumentaba a lo largo del tiempo en modelos tradicionales.  
âš¡ **Agile** busca que el costo del cambio se mantenga estable o incluso disminuya gracias a la adaptabilidad continua.


## ğŸ› ï¸ Enfoque actual de la GCS

Actualmente, la **GestiÃ³n de la ConfiguraciÃ³n del Software** (GCS) se concibe como:

> Un conjunto de actividades destinadas a **identificar, administrar y organizar** los cambios en los productos de trabajo durante todo el ciclo de vida del software.

Esto implica:
- IdentificaciÃ³n y control de los productos que probablemente cambien.
- GestiÃ³n eficiente de versiones y variantes.
- Facilitar la incorporaciÃ³n de cambios, en lugar de reprimirla.

## ğŸ§  ConclusiÃ³n

- La definiciÃ³n de Pressman era vÃ¡lida en su contexto histÃ³rico.
- Hoy, el enfoque **no busca equilibrar la creatividad con el caos**, sino **potenciar la creatividad** dentro de un sistema **organizado y controlado**.
- La gestiÃ³n moderna del cambio **fomenta** la innovaciÃ³n continua **de manera estructurada**.


## ğŸ‘¶ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estÃ¡s dibujando con tus amigos:

- Antes, te decÃ­an: "Â¡No hagas mucho lÃ­o mientras dibujas!" (evitar el caos).
- Ahora, todos dibujan juntos y cada uno aporta sus ideas.
- Para que no se arruinen los dibujos, **ponen reglas**: cada uno usa un color diferente, guardan los dibujos en carpetas especiales (como control de versiones), y ven cada cambio que hacen.

Ya **no se trata de evitar el lÃ­o**, sino de **organizarse bien** para que **todos puedan crear juntos** algo hermoso.


### ğŸ¯ Resumen rÃ¡pido

| Aspecto            | Antes (Pressman)              | Ahora (VisiÃ³n actual)                      |
| ------------------ | ----------------------------- | ------------------------------------------ |
| Enemigo principal  | Caos                          | Mala organizaciÃ³n                          |
| Enfoque            | Equilibrar creatividad y caos | Organizar la creatividad continua          |
| Herramientas clave | Procedimientos rÃ­gidos        | Control de versiones, integraciÃ³n continua |
| Mentalidad         | Prevenir el caos              | Gestionar la creatividad                   |

---

# ğŸ“‚ Â¿CuÃ¡les son las tres ubicaciones principales en un repositorio GIT?

En Git, un repositorio tiene **tres Ã¡reas principales**:


## 1. Working Tree (Carpeta de trabajo)

- Es el **directorio** donde ves y editas los archivos de tu proyecto en tu computadora.
- Contiene la **versiÃ³n actual** de los archivos que estÃ¡s desarrollando.

ğŸ“œ **Comando relacionado**:
- `git checkout <rama>` â†’ Actualiza el Working Tree con los archivos de una rama especÃ­fica.
- `git checkout <archivo>` â†’ Recupera un archivo especÃ­fico al estado de un commit o rama.


## 2. Staging Area (Ãrea de preparaciÃ³n)

- Es una **zona intermedia** donde preparas los cambios que quieres incluir en el prÃ³ximo commit.
- Solo los archivos en el Staging Area serÃ¡n incluidos en el siguiente commit.

ğŸ“œ **Comando relacionado**:
- `git add <archivo>` â†’ Mueve cambios desde el Working Tree al Staging Area.
- `git status` â†’ Muestra quÃ© archivos estÃ¡n preparados (staged) y cuÃ¡les no.

## 3. Local Repository (Repositorio local)

- Es la **base de datos interna** donde Git almacena todo el historial de versiones, commits, ramas y etiquetas del proyecto.
- Se encuentra en la carpeta oculta `.git` dentro del proyecto.

ğŸ“œ **Comando relacionado**:
- `git commit` â†’ Guarda los cambios del Staging Area en el Local Repository como un nuevo commit.
- `git branch` â†’ Muestra las ramas existentes en tu repositorio local.
- `git clone <url>` â†’ Crea una copia completa de un repositorio remoto en tu mÃ¡quina, incluyendo el Local Repository.


### ğŸ¯ Resumen Visual

| UbicaciÃ³n        | DescripciÃ³n                                 | Comando principal                       |
| ---------------- | ------------------------------------------- | --------------------------------------- |
| Working Tree     | Archivos visibles y editables               | `git checkout`                          |
| Staging Area     | Ãrea para preparar cambios antes del commit | `git add`                               |
| Local Repository | Historial completo de commits y ramas       | `git commit`, `git branch`, `git clone` |

----


# ğŸ§  Â¿QuÃ© es el "delta changes" en Git? Â¿Debe ser pequeÃ±o o grande?

## ğŸ“Œ DefiniciÃ³n de Delta Changes

- El **delta de cambios** (concepto mencionado por **Jez Humble**) es la **diferencia** entre una versiÃ³n (`commit`) y la siguiente en un repositorio de Git.
- Representa el **conjunto de modificaciones** realizadas a los **Elementos de ConfiguraciÃ³n (EC)** para transformar el proyecto de un estado a otro.
- Cada commit almacena ese delta: **lo que ha cambiado** respecto del commit anterior.


## ğŸ“ Â¿Debe ser pequeÃ±o o grande?

**El delta de cambios deberÃ­a ser pequeÃ±o** por las siguientes razones:

### âœ… Ventajas de deltas pequeÃ±os:

- **Menor probabilidad de conflictos**:  
  Menos riesgo de que dos personas modifiquen las mismas lÃ­neas de cÃ³digo simultÃ¡neamente.
  
- **Facilita la integraciÃ³n continua**:  
  Cambios pequeÃ±os permiten integrar cÃ³digo con mayor frecuencia y menos riesgos.
  
- **Aislamiento de errores**:  
  Si un cambio introduce un error, es mÃ¡s fÃ¡cil encontrarlo y revertirlo rÃ¡pidamente.
  
- **Mejor entendimiento del historial**:  
  Un historial de commits pequeÃ±o y lÃ³gico facilita entender la evoluciÃ³n del proyecto.
  
- **Revisiones de cÃ³digo mÃ¡s fÃ¡ciles**:  
  Los cambios pequeÃ±os son mÃ¡s rÃ¡pidos y claros para revisar entre compaÃ±eros de equipo.


## ğŸ¯ Â¿QuÃ© se recomienda?

- **Hacer commits frecuentemente**, al menos una vez por dÃ­a o al finalizar una tarea significativa (como una Historia de Usuario - HU).
- **Agrupar cambios lÃ³gicos**:  
  No hacer commits excesivamente pequeÃ±os e inconexos. Un buen commit debe representar un avance o modificaciÃ³n coherente.


### ğŸš€ Resumen Visual

| Aspecto                   | Delta pequeÃ±o | Delta grande   |
| ------------------------- | ------------- | -------------- |
| Riesgo de conflictos      | Bajo          | Alto           |
| DetecciÃ³n de errores      | FÃ¡cil         | DifÃ­cil        |
| IntegraciÃ³n continua      | Facilitada    | Obstaculizada  |
| RevisiÃ³n de cÃ³digo        | Ãgil          | Lenta y pesada |
| ComprensiÃ³n del historial | Clara         | Confusa        |

---

# ğŸš€ Estrategias de Despliegue: Blue-Green Deployment y Canary Release

## ğŸ“˜ Blue-Green Deployment

### Â¿QuÃ© es?

- Se utilizan **dos entornos de producciÃ³n idÃ©nticos**, llamados **Azul** y **Verde**.
- En un momento dado, **uno** (por ejemplo, Azul) estÃ¡ **activo** y recibiendo trÃ¡fico de usuarios.
- Se despliega la **nueva versiÃ³n** en el entorno **inactivo** (por ejemplo, Verde).
- Una vez probada la nueva versiÃ³n, el **enrutador** se cambia para que el trÃ¡fico vaya al entorno Verde.
- **Rollback** rÃ¡pido: Si la nueva versiÃ³n falla, el trÃ¡fico se puede redirigir rÃ¡pidamente al entorno Azul.

### Ejemplo

> Imagina que tienes dos salas de juegos: **Sala Azul** y **Sala Verde**.  
> Los niÃ±os juegan en la Azul. Cuando tienes un juego nuevo, lo pruebas en la Verde.  
> Si todo sale bien, abres la Verde y cierras la Azul.  
> Si algo sale mal, Â¡vuelves a abrir la Azul!


## ğŸ¦ Canary Release

### Â¿QuÃ© es?

- Se despliega la nueva versiÃ³n de software **a un pequeÃ±o grupo de usuarios** primero ("los canarios").
- Se **monitoriza** el comportamiento real de esos usuarios.
- Si todo funciona bien, la nueva versiÃ³n se **amplÃ­a** gradualmente a mÃ¡s usuarios.
- Si se detectan problemas, **solo afecta a un pequeÃ±o grupo** y se puede detener o revertir la actualizaciÃ³n fÃ¡cilmente.

### Ejemplo

> Imagina que tienes una heladerÃ­a.  
> Antes de ofrecer un nuevo sabor de helado a todos, le das una muestra a unos pocos clientes ("canarios").  
> Si les gusta, empiezas a ofrecerlo a mÃ¡s personas.  
> Si no les gusta, dejas de venderlo y nadie mÃ¡s se entera.


## ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

## ğŸ› Blue-Green Deployment

> Imagina que en el parque hay **dos toboganes iguales**, uno **AZUL** y uno **VERDE**.  
> Todos los niÃ±os usan el tobogÃ¡n AZUL.  
> Cuando traen un tobogÃ¡n nuevo, lo prueban en el VERDE.  
> Si el nuevo tobogÃ¡n es divertido y seguro, abren el VERDE y cierran el AZUL.  
> Si el nuevo tobogÃ¡n no sirve, Â¡vuelven a abrir el AZUL!

## ğŸª Canary Release

> Imagina que estÃ¡s horneando galletas nuevas.  
> Primero le das **una sola galleta** a un amigo para ver si le gusta.  
> Si le gusta y no le duele la pancita, les das galletas a mÃ¡s amigos.  
> Si no le gusta o se siente mal, Â¡dejas de dar esa galleta nueva!

---

# ğŸ› ï¸ IntegraciÃ³n Continua (IC)

## Â¿Es una prÃ¡ctica, tÃ©cnica o metodologÃ­a?

- **IntegraciÃ³n Continua es una *prÃ¡ctica* Ã¡gil**.
- Fue propuesta inicialmente en **Extreme Programming (XP)**.

## Breve definiciÃ³n

> **IntegraciÃ³n Continua** es la prÃ¡ctica de desarrollo de software donde los miembros de un equipo integran su trabajo frecuentemente (al menos una vez al dÃ­a).  
> Cada integraciÃ³n es verificada por una **build automÃ¡tica** (que incluye pruebas automÃ¡ticas) para detectar errores de integraciÃ³n lo mÃ¡s rÃ¡pido posible.


### ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

> Imagina que varios amigos estÃ¡n construyendo un castillo de bloques.  
> Cada vez que un amigo termina de poner algunos bloques, **los junta con lo que ya hicieron los demÃ¡s**.  
> Un **robot especial** revisa enseguida si los bloques nuevos encajan bien y si el castillo sigue siendo fuerte.  
> Si algo falla, lo descubren rÃ¡pido y lo arreglan fÃ¡cilmente.  
> AsÃ­, el castillo se construye poquito a poco, pero siempre estando seguros de que no se derrumbe.


---

# ğŸš€ Diferencia principal entre Continuous Delivery y Continuous Deployment

La diferencia principal entre **Continuous Delivery (Entrega Continua)** y **Continuous Deployment (Despliegue Continuo)** es:

- **Continuous Delivery (Entrega Continua):**  
  El software siempre estÃ¡ listo para ser desplegado, pero **alguien debe decidir manualmente cuÃ¡ndo** enviarlo a producciÃ³n (por ejemplo, un Product Owner apretando un botÃ³n).

- **Continuous Deployment (Despliegue Continuo):**  
  Cada vez que un cambio pasa todas las pruebas y etapas de verificaciÃ³n, **se despliega automÃ¡ticamente a producciÃ³n**, sin intervenciÃ³n humana.

ğŸ‘‰ **Resumen:**  
- Entrega Continua: "EstÃ¡ listo, pero decidimos cuÃ¡ndo enviarlo."
- Despliegue Continuo: "Si estÃ¡ listo y todo bien, Â¡se envÃ­a solo!"


## ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que estamos construyendo un juguete nuevo:

- **Entrega Continua:**  
  Es como tener el juguete terminado en una caja, listo para jugar. Pero **nosotros decidimos cuÃ¡ndo abrir la caja** y dÃ¡rselo a los demÃ¡s para que jueguen.

- **Despliegue Continuo:**  
  Es como que, **cada vez que terminamos de pegar una pieza y estÃ¡ perfecta, automÃ¡ticamente se la damos a los niÃ±os para que empiecen a jugar**. Â¡No esperamos a terminar todo para empezar la diversiÃ³n!


---

# ğŸ¯ Ventajas de Implementar IntegraciÃ³n Continua (IC)

**1. Reducir riesgos y tiempos:**  
   Al integrar el trabajo frecuentemente, los problemas de integraciÃ³n se detectan de manera temprana, lo que disminuye el riesgo de fallos mayores al final del proyecto y reduce el tiempo necesario para corregirlos.

**2. Reducir procesos manuales repetitivos:**  
   La automatizaciÃ³n de la construcciÃ³n y las pruebas elimina tareas manuales que consumen tiempo y son propensas a errores.

**3. Generar software desplegable en cualquier momento y en cualquier lugar:**  
   Un sistema de IC bien configurado asegura que siempre haya una versiÃ³n del software lista para ser desplegada.


# ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que varios amigos estÃ¡n construyendo un castillo de Legos.  

**1. Menos problemas:**  
   En lugar de que cada amigo construya una parte por su lado y solo al final intenten juntarlo todo, con la IntegraciÃ³n Continua, cada vez que un amigo termina de poner algunos Legos, los junta con lo que ya hicieron los demÃ¡s. Si una pieza no encaja bien, Â¡lo descubren enseguida y es fÃ¡cil cambiarla!

**2. Menos trabajo aburrido:**  
   TambiÃ©n hay un robot automÃ¡tico que revisa si los Legos estÃ¡n bien puestos despuÃ©s de cada vez que juntan partes. Â¡AsÃ­ no tienen que revisar todo a mano y pueden seguir construyendo cosas nuevas!

**3. Castillo listo en cualquier momento:**  
   Como van juntando las partes todo el tiempo, si alguien quiere ver cÃ³mo va el castillo, siempre hay una parte casi terminada para mostrar. Â¡No tienen que esperar hasta el final!

**4. Cambios fÃ¡ciles:**  
   Si quieren aÃ±adir una torre mÃ¡s pequeÃ±a o cambiar una pared de sitio, como los cambios son pequeÃ±os cada vez que juntan Legos, es mÃ¡s fÃ¡cil hacer esos cambios sin que se caiga todo el castillo.

**5. Todos saben cÃ³mo va:**  
   Todos los amigos pueden ver cÃ³mo va el castillo y si hay algÃºn problema. Â¡AsÃ­ todos pueden ayudar a que quede genial!

**6. MÃ¡s confianza:**  
   Como el robot revisa todo y los problemas se arreglan pronto, los amigos constructores estÃ¡n mÃ¡s seguros de que su castillo serÃ¡ el mejor.


---

# ğŸ”¨ Â¿QuÃ© es una Build? Â¿Y una Build AutomÃ¡tica?

SegÃºn las fuentes:

- **Build:**  
  Es el proceso de combinar correctamente las versiones de los componentes de un software (cÃ³digo, configuraciÃ³n, bases de datos, etc.) para **crear un programa ejecutable** que pueda ser entregado a un cliente o usuario final.  
  La build no solo compila el cÃ³digo fuente, sino que tambiÃ©n puede incluir:
  - Limpieza de archivos innecesarios.
  - CompilaciÃ³n del cÃ³digo.
  - IntegraciÃ³n de bases de datos.
  - EjecuciÃ³n de pruebas automatizadas.
  - InspecciÃ³n automÃ¡tica del cÃ³digo.
  - Despliegue del software.

- **Build automÃ¡tica:**  
  Es una build que se ejecuta **sin intervenciÃ³n manual**.  
  Se dispara automÃ¡ticamente por eventos como:
  - Subir (push) o fusionar (merge) cÃ³digo en un repositorio.
  - Solicitar un "pull request" hacia una rama especÃ­fica.
  - O simplemente en intervalos de tiempo programados.  
  Un **servidor de IntegraciÃ³n Continua (IC)** suele ser el encargado de lanzar las builds automÃ¡ticas.

ğŸ‘‰ **Resumen rÃ¡pido:**  
- Build: Combinar todo para hacer un programa ejecutable.
- Build automÃ¡tica: Lo mismo, pero **sin tener que hacerlo a mano** cada vez.


### ğŸª ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que tienes una receta para hacer galletas:

- **Build:**  
  Es como **juntar todos los ingredientes** (harina, azÃºcar, huevos), **mezclarlos** en un bol, y **meterlos al horno** para que salgan **galletas ricas**.  
  Â¡A veces tambiÃ©n probamos las galletas antes de regalarlas para ver si estÃ¡n bien hechas!

- **Build automÃ¡tica:**  
  Es como si tuviÃ©ramos una **mÃ¡quina mÃ¡gica** que, cada vez que **cambiamos un poquito** de la receta, **ella solita mezcla los ingredientes y hornea una nueva galleta**.  
  Â¡AsÃ­ siempre tenemos galletas listas para probar sin tener que hacerlo todo nosotros cada vez!


---

# ğŸ“š Â¿QuÃ© es un pipeline?

**ExplicaciÃ³n formal:**

Un **pipeline** (en desarrollo de software) es una serie de pasos automÃ¡ticos que el cÃ³digo sigue desde que un programador hace un cambio hasta que ese cambio estÃ¡ listo para ser usado (por ejemplo, en producciÃ³n).  
Cada paso del pipeline realiza una tarea importante, como:

- **Construir** el proyecto (build).
- **Ejecutar pruebas** para verificar que no haya errores.
- **Analizar** la calidad del cÃ³digo.
- **Preparar** el software para su despliegue (deploy).
- **Desplegarlo** finalmente a los usuarios.

Todo esto **sucede automÃ¡ticamente** siguiendo un flujo ordenado:  
ğŸ‘‰ cada paso depende del Ã©xito del anterior.  
ğŸ‘‰ si algo falla en medio, el pipeline se detiene para evitar problemas mayores.

Un **pipeline de IntegraciÃ³n Continua (CI)** incluye principalmente construir y probar.  
Un **pipeline de Entrega Continua (CD)** lleva el proceso mÃ¡s allÃ¡, hasta dejar el software listo para entregarlo o incluso entregarlo automÃ¡ticamente.


## ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que quieres hacer una **fÃ¡brica de pasteles mÃ¡gicos**:

- Pones los ingredientes en una mÃ¡quina.
- La mÃ¡quina mezcla todo.
- DespuÃ©s otra mÃ¡quina hornea el pastel.
- Luego otra lo decora con dulce de colores.
- Y al final otra mÃ¡quina lo pone en una cajita para regalarlo.

Cada mÃ¡quina hace su trabajo en orden, **una despuÃ©s de la otra**, **sin que tÃº tengas que hacer nada**.  
Â¡Solo tienes que poner los ingredientes al principio y esperar al final tu pastel listo! ğŸ‚âœ¨

Ese **camino de mÃ¡quinas trabajando juntas** se llama **pipeline**.  
Â¡Es como un tren de estaciones mÃ¡gicas para hacer cosas rÃ¡pido y sin errores! ğŸš‚ğŸ‚

---
# ğŸš€ Â¿Se puede implementar Entrega Continua sin un pipeline de IntegraciÃ³n Continua?

**Respuesta breve: No.**

SegÃºn las fuentes:

- No se puede implementar **Entrega Continua** si **no existe primero un pipeline de IntegraciÃ³n Continua** bien definido.
- La Entrega Continua se **construye sobre** la base de la IntegraciÃ³n Continua.
- Primero se necesita un sistema que:
  - Integre automÃ¡ticamente el cÃ³digo.
  - Compile (build) los cambios.
  - Realice pruebas automÃ¡ticas.
- Luego, sobre esa base confiable, se puede avanzar hacia automatizar la entrega hasta producciÃ³n.
- Sin una buena IntegraciÃ³n Continua, no podrÃ­as garantizar que el software estÃ© siempre listo para ser entregado.

ğŸ‘‰ **Resumen rÃ¡pido:**  
**IntegraciÃ³n Continua â†’ Entrega Continua.**  
Primero se asegura la base, despuÃ©s se construye el resto.


## ğŸ› ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que queremos construir un **tobogÃ¡n de agua gigante** para tirarnos a la piscina:

- Primero, necesitamos una **escalera fuerte** para subir seguros hasta arriba del tobogÃ¡n.  
  Esa escalera, que revisamos todo el tiempo para que no se rompa, es como la **IntegraciÃ³n Continua**:  
  ğŸ‘‰ Juntamos y revisamos todas las partes del programa.

- Luego, cuando tenemos la escalera bien hecha, **podemos construir el tobogÃ¡n** que nos lleva directo al agua.  
  Ese tobogÃ¡n divertido, donde podemos lanzarnos cuando queramos, es como la **Entrega Continua**.

**Si no tenemos una buena escalera**, no podemos construir un tobogÃ¡n seguro.  
Primero la escalera (**IntegraciÃ³n Continua**), despuÃ©s el tobogÃ¡n (**Entrega Continua**). ğŸ›ğŸ’¦


---

# ğŸ“š Componentes de un pipeline de IntegraciÃ³n Continua (IC)

Los **componentes principales** son:

- **Equipo:** Los desarrolladores que escriben el cÃ³digo y lo integran frecuentemente.
- **Control de versiones (Repositorio):** El lugar donde se guarda el cÃ³digo (como GitHub, GitLab o Bitbucket).
- **Servidor de IC:** El sistema que detecta cambios en el cÃ³digo, construye el software, corre pruebas y verifica que todo funcione bien.
- **Entorno de entrega:** Lugares donde se despliega el software para probarlo o para que lo usen los usuarios.
- **Mecanismo de feedback:** Herramientas que avisan al equipo si hubo errores o todo saliÃ³ bien (correo, Slack, notificaciones).
- **Build script:** El conjunto de instrucciones que guÃ­a al servidor sobre cÃ³mo debe construir, probar y preparar el software.


# ğŸš€ FunciÃ³n del servidor de IntegraciÃ³n Continua (IC)

El **servidor de IC** se encarga de:

- Descargar el cÃ³digo nuevo del repositorio.
- Limpiar archivos viejos o innecesarios.
- Compilar el cÃ³digo para generar un programa ejecutable.
- Integrar bases de datos, si hace falta.
- Ejecutar pruebas automÃ¡ticas para buscar errores rÃ¡pido.
- Revisar la calidad del cÃ³digo.
- (Opcionalmente) Desplegar el software para su uso.

> **Resumen:** El servidor de IC **automatiza** todo el proceso de asegurarse de que el cÃ³digo nuevo funcione correctamente.


## ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

Imagina que tÃº y tus amigos estÃ¡n construyendo un robot de bloques:

- **Tus amigos (Equipo):** Son los que ponen nuevas piezas para construir el robot.
- **La gran caja de bloques (Control de versiones):** Es donde todos guardan las piezas y las instrucciones para construir.
- **El robot constructor mÃ¡gico (Servidor de IC):** Es un robot que, cada vez que alguien pone una nueva pieza en la caja, agarra todas las piezas, arma el robot y revisa que funcione bien.
- **La mesa de pruebas (Entorno de entrega):** Es donde el robot armado se prueba para ver si camina, enciende luces o baila.
- **El megÃ¡fono mÃ¡gico (Mecanismo de feedback):** Si algo estÃ¡ mal, el megÃ¡fono grita: "Â¡Alto, hay que arreglar esto!".
- **El librito de instrucciones (Build script):** Le dice al robot constructor mÃ¡gico quÃ© pasos seguir para armar el robot.

ğŸ‘‰ **El robot constructor mÃ¡gico (servidor de IC)** trabaja todo el dÃ­a ayudando a armar y revisar el robot para que siempre estÃ© bien hecho.  
Â¡AsÃ­ no tienen que estar construyendo y revisando todo a mano cada vez!

---

# ğŸ› ï¸ Anti-patterns en IntegraciÃ³n y Entrega Continua

Teniendo en cuenta lo visto sobre integraciÃ³n y entrega continua, podemos definir dos **anti-patterns**:

## âŒ 1. Ignorar o no arreglar rÃ¡pidamente las "builds" rotas

- En la IntegraciÃ³n Continua, es crucial arreglar cualquier error detectado de inmediato.
- Si una "build" falla (porque no compila o fallan las pruebas) y no se soluciona rÃ¡pido, los errores se acumulan.
- Esto hace que luego sea mucho mÃ¡s difÃ­cil encontrar y corregir los problemas.
- **Rompe** el objetivo de detectar y corregir errores temprano.

## âŒ 2. Confundir "CompilaciÃ³n Continua" con "IntegraciÃ³n Continua"

- A veces las organizaciones solo configuran que el cÃ³digo **se compile automÃ¡ticamente** cuando hay cambios.
- Pero **compilar** no es suficiente: faltan pruebas automÃ¡ticas, revisiones de calidad y validaciones importantes.
- La IntegraciÃ³n Continua implica **mucho mÃ¡s** que compilar: debe garantizar la calidad del software en cada cambio.


## ğŸˆ ExplicaciÃ³n para un niÃ±o de 5 aÃ±os

## ğŸ§± Anti-patrÃ³n 1: No arreglar los juguetes rotos rÃ¡pido

Imagina que estÃ¡s construyendo una torre con bloques.  
Cada vez que pones un bloque, una mÃ¡quina mÃ¡gica revisa si la torre estÃ¡ bien.

- Si pones un bloque y la torre **se tambalea** (Â¡oh no!), pero **no lo arreglas** y sigues poniendo mÃ¡s bloques...
- Â¡La torre puede caerse entera!
- **Â¿QuÃ© es mejor?** Arreglar rÃ¡pido el bloque flojo para que la torre siga fuerte y no se derrumbe.

## ğŸ Anti-patrÃ³n 2: Pensar que solo guardar los juguetes en la caja es suficiente

Imagina que tienes una caja mÃ¡gica que **guarda automÃ¡ticamente** todos tus juguetes cuando terminas de jugar.

- Pero la caja **no revisa** si los juguetes estÃ¡n **rotos o sucios**.
- AsÃ­ que, la prÃ³xima vez que quieras jugar, algunos juguetes estarÃ¡n rotos o sucios.
- **Â¿QuÃ© es mejor?** Revisar y arreglar los juguetes antes de guardarlos, asÃ­ la prÃ³xima vez estÃ¡n perfectos para jugar.

> ğŸ‘‰ De la misma forma, en la computadora **no basta** con guardar el programa automÃ¡ticamente: Â¡hay que revisarlo y probarlo para que funcione bien!

---
