

---

# 🛠️ Gestión de la Configuración (GCS)

> 1. Defina gestión de la configuración. Explique por qué es necesario.

## 📖 Definición

La **Gestión de la Configuración de Software (GCS)** es el arte de **identificar, organizar, revisar y controlar** todos los cambios que se hacen en el software que construye un equipo.  
Es un conjunto de actividades que comienza cuando inicia un proyecto de software y termina cuando el software deja de usarse.

Su objetivo es **hacer el trabajo más fácil**, **evitar errores** y **mantener el orden** en el proyecto.

## ❓ ¿Por qué es necesaria?

La Gestión de la Configuración es necesaria para:

- 📦 **Identificar** todos los elementos que forman el software (código, documentos, datos).
- 🔄 **Administrar los cambios** de manera controlada, evitando que el proyecto se convierta en un caos.
- 🛠️ **Facilitar la creación de diferentes versiones** del software.
- ✅ **Asegurar la calidad** del software a medida que se realizan cambios.
- 🧩 **Rastrear y analizar** todos los cambios hechos en el proyecto.
- 📢 **Informar a todo el equipo** sobre qué cambios se hicieron y cuándo.

Sin una buena gestión de la configuración, los proyectos podrían:

- Volverse desorganizados,
- Perder calidad,
- Retrasarse en las entregas.


## 👶 Explicación para un niño de 5 años

Imagina que estás construyendo un **castillo de Legos** con tus amigos.  
La **Gestión de la Configuración** sería como tener un **encargado** que:

- 📋 **Sabe qué piezas** tiene el castillo (qué Legos usaron).
- ✍️ **Anota quién puso qué bloque** y **cuándo**.
- 📚 **Cuida las instrucciones** y se asegura de que todos sepan qué parte están construyendo.
- 🏗️ Si alguien quiere **cambiar algo** (por ejemplo, hacer una torre más alta), el encargado:
  - Se asegura de que **todos estén de acuerdo**,
  - Verifica que el cambio **no destruya** otra parte del castillo.

Así, el castillo se construye de forma ordenada, **sin romperse** y **sin hacer lío**.

### 🎯 Resumen

La GCS es como tener un jefe de los Legos que cuida que todo esté ordenado y seguro mientras construimos un gran castillo entre todos.


---

# 🛠️ Diferencia entre Mantenimiento y Gestión de la Configuración (GCS)

## ❓ ¿Por qué **mantenimiento** no es lo mismo que **GCS**?

La **Gestión de la Configuración (GCS)** y el **mantenimiento** son actividades distintas dentro del ciclo de vida del software:

## 🛠️ Mantenimiento de Software

- Es un **conjunto de actividades** que ocurren **después** de que el software se entrega al cliente y comienza a usarse.
- Incluye:
  - 🔧 **Arreglar errores** encontrados en el uso real.
  - 🌟 **Hacer pequeñas mejoras** o adaptaciones.
- En metodologías ágiles, el mantenimiento puede hacerse de manera **continua**, no como una etapa aparte.


## 📦 Gestión de la Configuración de Software (GCS)

- Es un conjunto de actividades que **empieza cuando el proyecto comienza** y **termina cuando el software deja de usarse**.
- Se encarga de:
  - 🗂️ **Organizar y controlar** todos los cambios en el software.
  - 🧩 **Identificar versiones** de cada parte del software.
  - 🕵️ **Seguir el rastro** de qué cambios se hicieron, cuándo y por qué.


## 👶 Explicación para un niño de 5 años

Imagina que estás construyendo un **castillo de Legos**:

- 🏰 **Mantenimiento**:
  - Es cuando **ya terminaste** el castillo,
  - Estás jugando con él,
  - Y de repente una **torre se rompe** o quieres ponerle una **bandera nueva**.
  - Entonces lo **arreglas** o le haces mejoras.
  - Esto pasa **después** de que el castillo está listo.

- 📋 **Gestión de la Configuración (GCS)**:
  - Es como tener un **encargado** que:
    - **Desde el principio** te ayuda a construir,
    - **Anota** qué piezas usaste,
    - **Controla** si cambiaste algo,
    - Y **se asegura** de que todo esté bien armado.
  - Está **todo el tiempo**: mientras construyes, cuando terminas, y cuando arreglas algo.
  - No aparece solo cuando el castillo ya está roto, **está desde el primer momento**.

### 🎯 Resumen

- El **mantenimiento** empieza **después** de que el software está entregado.
- La **GCS** trabaja **durante todo el proyecto**, desde el primer día hasta el último.

---
# 🧩 ¿Qué es un Artefacto de Software?

## Definición

Un **artefacto de software** es **cualquier cosa que se crea** durante la construcción de un programa de computadora.

Son como las **piezas** y **documentos** necesarios para construir el software y entender cómo funciona.

## 📋 Ejemplos de artefactos de software

- 📄 Documentos con las **ideas** o **requisitos** de lo que debe hacer el programa.
- 🎨 **Dibujos** o **diagramas** de cómo se verá el programa.
- 🧑‍💻 **Código fuente**: instrucciones escritas para que la computadora entienda qué hacer.
- 🧪 **Pruebas** (tests) para asegurarse de que el programa funciona bien.
- 📚 **Manuales** de uso para que las personas sepan cómo usar el programa.


## 👶 Explicación para un niño de 5 años

Imagina que estás construyendo un **castillo de Legos**. Los artefactos de software serían:

- ✏️ El **dibujo** que hiciste de cómo querías que fuera el castillo.
- 🧱 La **caja** con todas las piezas de Lego.
- 📜 Las **instrucciones** que te dicen cómo encajar las piezas.
- 🚪 Probar si la **puerta** del castillo se abre y se cierra bien.
- 📝 Un **papel** donde escribes para tu amigo cómo construiste una torre, para que él también pueda hacer una igual.

Todas estas cosas (el dibujo, las piezas, las instrucciones, las pruebas y las notas) son **artefactos**: son **todo lo que creaste o usaste** mientras hacías tu castillo.

### 🎯 Resumen

Un artefacto de software es **todo lo que produces** mientras haces un programa: documentos, dibujos, código, pruebas, instrucciones y más.

---

# 🔄 Diferencias entre Versión, Revisión y Variante

## 📖 Conceptos

- **Versión**:  
  Es una **instancia específica** de un artefacto de software, distinta de otras instancias.  
  ➡️ *Ejemplo*: La **versión 1.0** de un juego.

- **Revisión**:  
  Es una **nueva versión** que **corrige o mejora** versiones anteriores.  
  ➡️ *Ejemplo*: La **versión 1.1** del juego corrige errores encontrados en la 1.0.  
  ➡️ *Otro ejemplo*: **Windows 7** es una revisión de **Windows Vista**.

- **Variante**:  
  Es una **versión alternativa** que **agrega funciones o características**, pero **no reemplaza** a las versiones anteriores.  
  ➡️ *Ejemplo*: Una versión "**Pro**" de un programa que tiene más funciones que la versión básica.


## 👶 Explicación para un niño de 5 años

Imagina que estás dibujando un **sol**:

- 🌞 **Versión**:  
  Haces un dibujo de un sol amarillo con 8 rayitos.  
  Luego haces otro dibujo de un sol naranja con 10 rayitos.  
  ➡️ ¡Son dos versiones diferentes de tu sol!

- 🛠️ **Revisión**:  
  Ves que en tu primer dibujo algunos rayitos quedaron chuecos.  
  Los borras y los dibujas más derechos.  
  ➡️ Eso es una revisión: **arreglaste** tu sol para que quede mejor.

- 😎 **Variante**:  
  Agarras tu sol amarillo y le dibujas unas **gafas de sol**.  
  ➡️ ¡Ahora tu sol tiene algo nuevo!  
  Es una variante: **añadiste algo extra** sin borrar tu dibujo original.


### 🎯 Resumen Final

| Concepto  | Qué es                                                   | Ejemplo                       |
|-----------|-----------------------------------------------------------|-------------------------------|
| Versión   | Un artefacto en un momento dado.                           | Juego versión 1.0             |
| Revisión  | Una corrección o mejora de una versión anterior.           | Juego versión 1.1 (corrige errores) |
| Variante  | Una versión alternativa que agrega características nuevas. | Versión "Pro" de un programa   |

---


# 🔍 Trazabilidad entre dos Ítems de Configuración (IC)

## 📖 Concepto

La **trazabilidad** entre dos Ítems de Configuración (IC) es la **capacidad de identificar y seguir la conexión** entre dos elementos distintos que forman parte de un sistema de software.

Un **Ítem de Configuración** (IC) puede ser:
- Un documento de requisitos
- Un fragmento de código
- Un diseño de interfaz
- Una prueba, entre otros.

La trazabilidad permite:
- Ver **qué elemento depende de otro**.
- Entender **por qué existe** un elemento.
- Saber **qué impacto** tiene cambiar algo.

## 🎯 Ejemplo

- **Requisito (IC 1):**  
  "El usuario debe poder hacer clic en un botón que diga 'Guardar'".

- **Código (IC 2):**  
  El fragmento de código que crea el botón "Guardar" y guarda la información cuando se hace clic.

**La trazabilidad** es la **relación directa** entre:
- El requisito que pide el botón.
- Y el código que implementa el botón.

Así, si mañana se cambia el requisito (por ejemplo, que el botón diga "Enviar" en lugar de "Guardar"), **sabemos exactamente qué código tenemos que modificar**.

## 👶 Explicación para un niño de 5 años

Imagina que construyes un castillo de Legos:

- 📜 **Instrucción (IC 1):**  
  "Pon un bloque rojo encima de la torre más alta".

- 🧱 **Acción (IC 2):**  
  Colocas un bloque rojo en la torre más alta.

**La trazabilidad** es **saber que ese bloque rojo está ahí** porque **una instrucción** te dijo que lo pusieras.

➡️ Si la torre se cae o si quieren cambiar el color del bloque, sabes **exactamente cuál instrucción seguir** para arreglarlo o modificarlo.


### 🎯 Resumen Rápido

| Concepto                   | Qué es                                      | Ejemplo                                |
| -------------------------- | ------------------------------------------- | -------------------------------------- |
| Ítem de Configuración (IC) | Cualquier elemento importante del software. | Requisito, código, diseño, prueba      |
| Trazabilidad               | Saber cómo un IC se relaciona con otro IC.  | Requisito del botón ↔ Código del botón |


---

# 🎨 Control del Cambio en la GCS: ¿Sigue vigente la definición de Pressman?

## 📖 Definición tradicional según Pressman

Dentro de la Gestión de la Configuración del Software (GCS), **Pressman** definió el control como:

> "La búsqueda del equilibrio entre creatividad y caos".

Esta idea reflejaba la tensión clásica en el desarrollo de software entre:
- La **creatividad** necesaria para innovar y crear nuevas soluciones.
- El **caos** que surge cuando los cambios no se controlan adecuadamente.

## 🔄 Visión actual del control del cambio

Hoy en día, con el auge de las **metodologías ágiles**, la visión sobre el control del cambio ha evolucionado:

- **Ya no se trata de creatividad vs. caos**, sino de **gestionar múltiples fuentes de creatividad** de manera organizada.
- **El cambio es constante** y se fomenta su incorporación temprana y frecuente, en lugar de temerle.
- **Herramientas modernas** (control de versiones, integración continua, automatización de pruebas) permiten gestionar cambios **sin generar caos**.

📈 **La curva de Boehm** enseñaba que el costo del cambio aumentaba a lo largo del tiempo en modelos tradicionales.  
⚡ **Agile** busca que el costo del cambio se mantenga estable o incluso disminuya gracias a la adaptabilidad continua.


## 🛠️ Enfoque actual de la GCS

Actualmente, la **Gestión de la Configuración del Software** (GCS) se concibe como:

> Un conjunto de actividades destinadas a **identificar, administrar y organizar** los cambios en los productos de trabajo durante todo el ciclo de vida del software.

Esto implica:
- Identificación y control de los productos que probablemente cambien.
- Gestión eficiente de versiones y variantes.
- Facilitar la incorporación de cambios, en lugar de reprimirla.

## 🧠 Conclusión

- La definición de Pressman era válida en su contexto histórico.
- Hoy, el enfoque **no busca equilibrar la creatividad con el caos**, sino **potenciar la creatividad** dentro de un sistema **organizado y controlado**.
- La gestión moderna del cambio **fomenta** la innovación continua **de manera estructurada**.


## 👶 Explicación para un niño de 5 años

Imagina que estás dibujando con tus amigos:

- Antes, te decían: "¡No hagas mucho lío mientras dibujas!" (evitar el caos).
- Ahora, todos dibujan juntos y cada uno aporta sus ideas.
- Para que no se arruinen los dibujos, **ponen reglas**: cada uno usa un color diferente, guardan los dibujos en carpetas especiales (como control de versiones), y ven cada cambio que hacen.

Ya **no se trata de evitar el lío**, sino de **organizarse bien** para que **todos puedan crear juntos** algo hermoso.


### 🎯 Resumen rápido

| Aspecto            | Antes (Pressman)              | Ahora (Visión actual)                      |
| ------------------ | ----------------------------- | ------------------------------------------ |
| Enemigo principal  | Caos                          | Mala organización                          |
| Enfoque            | Equilibrar creatividad y caos | Organizar la creatividad continua          |
| Herramientas clave | Procedimientos rígidos        | Control de versiones, integración continua |
| Mentalidad         | Prevenir el caos              | Gestionar la creatividad                   |

---

# 📂 ¿Cuáles son las tres ubicaciones principales en un repositorio GIT?

En Git, un repositorio tiene **tres áreas principales**:


## 1. Working Tree (Carpeta de trabajo)

- Es el **directorio** donde ves y editas los archivos de tu proyecto en tu computadora.
- Contiene la **versión actual** de los archivos que estás desarrollando.

📜 **Comando relacionado**:
- `git checkout <rama>` → Actualiza el Working Tree con los archivos de una rama específica.
- `git checkout <archivo>` → Recupera un archivo específico al estado de un commit o rama.


## 2. Staging Area (Área de preparación)

- Es una **zona intermedia** donde preparas los cambios que quieres incluir en el próximo commit.
- Solo los archivos en el Staging Area serán incluidos en el siguiente commit.

📜 **Comando relacionado**:
- `git add <archivo>` → Mueve cambios desde el Working Tree al Staging Area.
- `git status` → Muestra qué archivos están preparados (staged) y cuáles no.

## 3. Local Repository (Repositorio local)

- Es la **base de datos interna** donde Git almacena todo el historial de versiones, commits, ramas y etiquetas del proyecto.
- Se encuentra en la carpeta oculta `.git` dentro del proyecto.

📜 **Comando relacionado**:
- `git commit` → Guarda los cambios del Staging Area en el Local Repository como un nuevo commit.
- `git branch` → Muestra las ramas existentes en tu repositorio local.
- `git clone <url>` → Crea una copia completa de un repositorio remoto en tu máquina, incluyendo el Local Repository.


### 🎯 Resumen Visual

| Ubicación        | Descripción                                 | Comando principal                       |
| ---------------- | ------------------------------------------- | --------------------------------------- |
| Working Tree     | Archivos visibles y editables               | `git checkout`                          |
| Staging Area     | Área para preparar cambios antes del commit | `git add`                               |
| Local Repository | Historial completo de commits y ramas       | `git commit`, `git branch`, `git clone` |

----


# 🧠 ¿Qué es el "delta changes" en Git? ¿Debe ser pequeño o grande?

## 📌 Definición de Delta Changes

- El **delta de cambios** (concepto mencionado por **Jez Humble**) es la **diferencia** entre una versión (`commit`) y la siguiente en un repositorio de Git.
- Representa el **conjunto de modificaciones** realizadas a los **Elementos de Configuración (EC)** para transformar el proyecto de un estado a otro.
- Cada commit almacena ese delta: **lo que ha cambiado** respecto del commit anterior.


## 📏 ¿Debe ser pequeño o grande?

**El delta de cambios debería ser pequeño** por las siguientes razones:

### ✅ Ventajas de deltas pequeños:

- **Menor probabilidad de conflictos**:  
  Menos riesgo de que dos personas modifiquen las mismas líneas de código simultáneamente.
  
- **Facilita la integración continua**:  
  Cambios pequeños permiten integrar código con mayor frecuencia y menos riesgos.
  
- **Aislamiento de errores**:  
  Si un cambio introduce un error, es más fácil encontrarlo y revertirlo rápidamente.
  
- **Mejor entendimiento del historial**:  
  Un historial de commits pequeño y lógico facilita entender la evolución del proyecto.
  
- **Revisiones de código más fáciles**:  
  Los cambios pequeños son más rápidos y claros para revisar entre compañeros de equipo.


## 🎯 ¿Qué se recomienda?

- **Hacer commits frecuentemente**, al menos una vez por día o al finalizar una tarea significativa (como una Historia de Usuario - HU).
- **Agrupar cambios lógicos**:  
  No hacer commits excesivamente pequeños e inconexos. Un buen commit debe representar un avance o modificación coherente.


### 🚀 Resumen Visual

| Aspecto                   | Delta pequeño | Delta grande   |
| ------------------------- | ------------- | -------------- |
| Riesgo de conflictos      | Bajo          | Alto           |
| Detección de errores      | Fácil         | Difícil        |
| Integración continua      | Facilitada    | Obstaculizada  |
| Revisión de código        | Ágil          | Lenta y pesada |
| Comprensión del historial | Clara         | Confusa        |

---

# 🚀 Estrategias de Despliegue: Blue-Green Deployment y Canary Release

## 📘 Blue-Green Deployment

### ¿Qué es?

- Se utilizan **dos entornos de producción idénticos**, llamados **Azul** y **Verde**.
- En un momento dado, **uno** (por ejemplo, Azul) está **activo** y recibiendo tráfico de usuarios.
- Se despliega la **nueva versión** en el entorno **inactivo** (por ejemplo, Verde).
- Una vez probada la nueva versión, el **enrutador** se cambia para que el tráfico vaya al entorno Verde.
- **Rollback** rápido: Si la nueva versión falla, el tráfico se puede redirigir rápidamente al entorno Azul.

### Ejemplo

> Imagina que tienes dos salas de juegos: **Sala Azul** y **Sala Verde**.  
> Los niños juegan en la Azul. Cuando tienes un juego nuevo, lo pruebas en la Verde.  
> Si todo sale bien, abres la Verde y cierras la Azul.  
> Si algo sale mal, ¡vuelves a abrir la Azul!


## 🐦 Canary Release

### ¿Qué es?

- Se despliega la nueva versión de software **a un pequeño grupo de usuarios** primero ("los canarios").
- Se **monitoriza** el comportamiento real de esos usuarios.
- Si todo funciona bien, la nueva versión se **amplía** gradualmente a más usuarios.
- Si se detectan problemas, **solo afecta a un pequeño grupo** y se puede detener o revertir la actualización fácilmente.

### Ejemplo

> Imagina que tienes una heladería.  
> Antes de ofrecer un nuevo sabor de helado a todos, le das una muestra a unos pocos clientes ("canarios").  
> Si les gusta, empiezas a ofrecerlo a más personas.  
> Si no les gusta, dejas de venderlo y nadie más se entera.


## 🎈 Explicación para un niño de 5 años

## 🛝 Blue-Green Deployment

> Imagina que en el parque hay **dos toboganes iguales**, uno **AZUL** y uno **VERDE**.  
> Todos los niños usan el tobogán AZUL.  
> Cuando traen un tobogán nuevo, lo prueban en el VERDE.  
> Si el nuevo tobogán es divertido y seguro, abren el VERDE y cierran el AZUL.  
> Si el nuevo tobogán no sirve, ¡vuelven a abrir el AZUL!

## 🍪 Canary Release

> Imagina que estás horneando galletas nuevas.  
> Primero le das **una sola galleta** a un amigo para ver si le gusta.  
> Si le gusta y no le duele la pancita, les das galletas a más amigos.  
> Si no le gusta o se siente mal, ¡dejas de dar esa galleta nueva!

---

# 🛠️ Integración Continua (IC)

## ¿Es una práctica, técnica o metodología?

- **Integración Continua es una *práctica* ágil**.
- Fue propuesta inicialmente en **Extreme Programming (XP)**.

## Breve definición

> **Integración Continua** es la práctica de desarrollo de software donde los miembros de un equipo integran su trabajo frecuentemente (al menos una vez al día).  
> Cada integración es verificada por una **build automática** (que incluye pruebas automáticas) para detectar errores de integración lo más rápido posible.


### 🎈 Explicación para un niño de 5 años

> Imagina que varios amigos están construyendo un castillo de bloques.  
> Cada vez que un amigo termina de poner algunos bloques, **los junta con lo que ya hicieron los demás**.  
> Un **robot especial** revisa enseguida si los bloques nuevos encajan bien y si el castillo sigue siendo fuerte.  
> Si algo falla, lo descubren rápido y lo arreglan fácilmente.  
> Así, el castillo se construye poquito a poco, pero siempre estando seguros de que no se derrumbe.


---

# 🚀 Diferencia principal entre Continuous Delivery y Continuous Deployment

La diferencia principal entre **Continuous Delivery (Entrega Continua)** y **Continuous Deployment (Despliegue Continuo)** es:

- **Continuous Delivery (Entrega Continua):**  
  El software siempre está listo para ser desplegado, pero **alguien debe decidir manualmente cuándo** enviarlo a producción (por ejemplo, un Product Owner apretando un botón).

- **Continuous Deployment (Despliegue Continuo):**  
  Cada vez que un cambio pasa todas las pruebas y etapas de verificación, **se despliega automáticamente a producción**, sin intervención humana.

👉 **Resumen:**  
- Entrega Continua: "Está listo, pero decidimos cuándo enviarlo."
- Despliegue Continuo: "Si está listo y todo bien, ¡se envía solo!"


## 🎈 Explicación para un niño de 5 años

Imagina que estamos construyendo un juguete nuevo:

- **Entrega Continua:**  
  Es como tener el juguete terminado en una caja, listo para jugar. Pero **nosotros decidimos cuándo abrir la caja** y dárselo a los demás para que jueguen.

- **Despliegue Continuo:**  
  Es como que, **cada vez que terminamos de pegar una pieza y está perfecta, automáticamente se la damos a los niños para que empiecen a jugar**. ¡No esperamos a terminar todo para empezar la diversión!


---

# 🎯 Ventajas de Implementar Integración Continua (IC)

**1. Reducir riesgos y tiempos:**  
   Al integrar el trabajo frecuentemente, los problemas de integración se detectan de manera temprana, lo que disminuye el riesgo de fallos mayores al final del proyecto y reduce el tiempo necesario para corregirlos.

**2. Reducir procesos manuales repetitivos:**  
   La automatización de la construcción y las pruebas elimina tareas manuales que consumen tiempo y son propensas a errores.

**3. Generar software desplegable en cualquier momento y en cualquier lugar:**  
   Un sistema de IC bien configurado asegura que siempre haya una versión del software lista para ser desplegada.


# 🎈 Explicación para un niño de 5 años

Imagina que varios amigos están construyendo un castillo de Legos.  

**1. Menos problemas:**  
   En lugar de que cada amigo construya una parte por su lado y solo al final intenten juntarlo todo, con la Integración Continua, cada vez que un amigo termina de poner algunos Legos, los junta con lo que ya hicieron los demás. Si una pieza no encaja bien, ¡lo descubren enseguida y es fácil cambiarla!

**2. Menos trabajo aburrido:**  
   También hay un robot automático que revisa si los Legos están bien puestos después de cada vez que juntan partes. ¡Así no tienen que revisar todo a mano y pueden seguir construyendo cosas nuevas!

**3. Castillo listo en cualquier momento:**  
   Como van juntando las partes todo el tiempo, si alguien quiere ver cómo va el castillo, siempre hay una parte casi terminada para mostrar. ¡No tienen que esperar hasta el final!

**4. Cambios fáciles:**  
   Si quieren añadir una torre más pequeña o cambiar una pared de sitio, como los cambios son pequeños cada vez que juntan Legos, es más fácil hacer esos cambios sin que se caiga todo el castillo.

**5. Todos saben cómo va:**  
   Todos los amigos pueden ver cómo va el castillo y si hay algún problema. ¡Así todos pueden ayudar a que quede genial!

**6. Más confianza:**  
   Como el robot revisa todo y los problemas se arreglan pronto, los amigos constructores están más seguros de que su castillo será el mejor.


---

# 🔨 ¿Qué es una Build? ¿Y una Build Automática?

Según las fuentes:

- **Build:**  
  Es el proceso de combinar correctamente las versiones de los componentes de un software (código, configuración, bases de datos, etc.) para **crear un programa ejecutable** que pueda ser entregado a un cliente o usuario final.  
  La build no solo compila el código fuente, sino que también puede incluir:
  - Limpieza de archivos innecesarios.
  - Compilación del código.
  - Integración de bases de datos.
  - Ejecución de pruebas automatizadas.
  - Inspección automática del código.
  - Despliegue del software.

- **Build automática:**  
  Es una build que se ejecuta **sin intervención manual**.  
  Se dispara automáticamente por eventos como:
  - Subir (push) o fusionar (merge) código en un repositorio.
  - Solicitar un "pull request" hacia una rama específica.
  - O simplemente en intervalos de tiempo programados.  
  Un **servidor de Integración Continua (IC)** suele ser el encargado de lanzar las builds automáticas.

👉 **Resumen rápido:**  
- Build: Combinar todo para hacer un programa ejecutable.
- Build automática: Lo mismo, pero **sin tener que hacerlo a mano** cada vez.


### 🍪 Explicación para un niño de 5 años

Imagina que tienes una receta para hacer galletas:

- **Build:**  
  Es como **juntar todos los ingredientes** (harina, azúcar, huevos), **mezclarlos** en un bol, y **meterlos al horno** para que salgan **galletas ricas**.  
  ¡A veces también probamos las galletas antes de regalarlas para ver si están bien hechas!

- **Build automática:**  
  Es como si tuviéramos una **máquina mágica** que, cada vez que **cambiamos un poquito** de la receta, **ella solita mezcla los ingredientes y hornea una nueva galleta**.  
  ¡Así siempre tenemos galletas listas para probar sin tener que hacerlo todo nosotros cada vez!


---

# 📚 ¿Qué es un pipeline?

**Explicación formal:**

Un **pipeline** (en desarrollo de software) es una serie de pasos automáticos que el código sigue desde que un programador hace un cambio hasta que ese cambio está listo para ser usado (por ejemplo, en producción).  
Cada paso del pipeline realiza una tarea importante, como:

- **Construir** el proyecto (build).
- **Ejecutar pruebas** para verificar que no haya errores.
- **Analizar** la calidad del código.
- **Preparar** el software para su despliegue (deploy).
- **Desplegarlo** finalmente a los usuarios.

Todo esto **sucede automáticamente** siguiendo un flujo ordenado:  
👉 cada paso depende del éxito del anterior.  
👉 si algo falla en medio, el pipeline se detiene para evitar problemas mayores.

Un **pipeline de Integración Continua (CI)** incluye principalmente construir y probar.  
Un **pipeline de Entrega Continua (CD)** lleva el proceso más allá, hasta dejar el software listo para entregarlo o incluso entregarlo automáticamente.


## 🎈 Explicación para un niño de 5 años

Imagina que quieres hacer una **fábrica de pasteles mágicos**:

- Pones los ingredientes en una máquina.
- La máquina mezcla todo.
- Después otra máquina hornea el pastel.
- Luego otra lo decora con dulce de colores.
- Y al final otra máquina lo pone en una cajita para regalarlo.

Cada máquina hace su trabajo en orden, **una después de la otra**, **sin que tú tengas que hacer nada**.  
¡Solo tienes que poner los ingredientes al principio y esperar al final tu pastel listo! 🎂✨

Ese **camino de máquinas trabajando juntas** se llama **pipeline**.  
¡Es como un tren de estaciones mágicas para hacer cosas rápido y sin errores! 🚂🎂

---
# 🚀 ¿Se puede implementar Entrega Continua sin un pipeline de Integración Continua?

**Respuesta breve: No.**

Según las fuentes:

- No se puede implementar **Entrega Continua** si **no existe primero un pipeline de Integración Continua** bien definido.
- La Entrega Continua se **construye sobre** la base de la Integración Continua.
- Primero se necesita un sistema que:
  - Integre automáticamente el código.
  - Compile (build) los cambios.
  - Realice pruebas automáticas.
- Luego, sobre esa base confiable, se puede avanzar hacia automatizar la entrega hasta producción.
- Sin una buena Integración Continua, no podrías garantizar que el software esté siempre listo para ser entregado.

👉 **Resumen rápido:**  
**Integración Continua → Entrega Continua.**  
Primero se asegura la base, después se construye el resto.


## 🛝 Explicación para un niño de 5 años

Imagina que queremos construir un **tobogán de agua gigante** para tirarnos a la piscina:

- Primero, necesitamos una **escalera fuerte** para subir seguros hasta arriba del tobogán.  
  Esa escalera, que revisamos todo el tiempo para que no se rompa, es como la **Integración Continua**:  
  👉 Juntamos y revisamos todas las partes del programa.

- Luego, cuando tenemos la escalera bien hecha, **podemos construir el tobogán** que nos lleva directo al agua.  
  Ese tobogán divertido, donde podemos lanzarnos cuando queramos, es como la **Entrega Continua**.

**Si no tenemos una buena escalera**, no podemos construir un tobogán seguro.  
Primero la escalera (**Integración Continua**), después el tobogán (**Entrega Continua**). 🛝💦


---

# 📚 Componentes de un pipeline de Integración Continua (IC)

Los **componentes principales** son:

- **Equipo:** Los desarrolladores que escriben el código y lo integran frecuentemente.
- **Control de versiones (Repositorio):** El lugar donde se guarda el código (como GitHub, GitLab o Bitbucket).
- **Servidor de IC:** El sistema que detecta cambios en el código, construye el software, corre pruebas y verifica que todo funcione bien.
- **Entorno de entrega:** Lugares donde se despliega el software para probarlo o para que lo usen los usuarios.
- **Mecanismo de feedback:** Herramientas que avisan al equipo si hubo errores o todo salió bien (correo, Slack, notificaciones).
- **Build script:** El conjunto de instrucciones que guía al servidor sobre cómo debe construir, probar y preparar el software.


# 🚀 Función del servidor de Integración Continua (IC)

El **servidor de IC** se encarga de:

- Descargar el código nuevo del repositorio.
- Limpiar archivos viejos o innecesarios.
- Compilar el código para generar un programa ejecutable.
- Integrar bases de datos, si hace falta.
- Ejecutar pruebas automáticas para buscar errores rápido.
- Revisar la calidad del código.
- (Opcionalmente) Desplegar el software para su uso.

> **Resumen:** El servidor de IC **automatiza** todo el proceso de asegurarse de que el código nuevo funcione correctamente.


## 🎈 Explicación para un niño de 5 años

Imagina que tú y tus amigos están construyendo un robot de bloques:

- **Tus amigos (Equipo):** Son los que ponen nuevas piezas para construir el robot.
- **La gran caja de bloques (Control de versiones):** Es donde todos guardan las piezas y las instrucciones para construir.
- **El robot constructor mágico (Servidor de IC):** Es un robot que, cada vez que alguien pone una nueva pieza en la caja, agarra todas las piezas, arma el robot y revisa que funcione bien.
- **La mesa de pruebas (Entorno de entrega):** Es donde el robot armado se prueba para ver si camina, enciende luces o baila.
- **El megáfono mágico (Mecanismo de feedback):** Si algo está mal, el megáfono grita: "¡Alto, hay que arreglar esto!".
- **El librito de instrucciones (Build script):** Le dice al robot constructor mágico qué pasos seguir para armar el robot.

👉 **El robot constructor mágico (servidor de IC)** trabaja todo el día ayudando a armar y revisar el robot para que siempre esté bien hecho.  
¡Así no tienen que estar construyendo y revisando todo a mano cada vez!

---

# 🛠️ Anti-patterns en Integración y Entrega Continua

Teniendo en cuenta lo visto sobre integración y entrega continua, podemos definir dos **anti-patterns**:

## ❌ 1. Ignorar o no arreglar rápidamente las "builds" rotas

- En la Integración Continua, es crucial arreglar cualquier error detectado de inmediato.
- Si una "build" falla (porque no compila o fallan las pruebas) y no se soluciona rápido, los errores se acumulan.
- Esto hace que luego sea mucho más difícil encontrar y corregir los problemas.
- **Rompe** el objetivo de detectar y corregir errores temprano.

## ❌ 2. Confundir "Compilación Continua" con "Integración Continua"

- A veces las organizaciones solo configuran que el código **se compile automáticamente** cuando hay cambios.
- Pero **compilar** no es suficiente: faltan pruebas automáticas, revisiones de calidad y validaciones importantes.
- La Integración Continua implica **mucho más** que compilar: debe garantizar la calidad del software en cada cambio.


## 🎈 Explicación para un niño de 5 años

## 🧱 Anti-patrón 1: No arreglar los juguetes rotos rápido

Imagina que estás construyendo una torre con bloques.  
Cada vez que pones un bloque, una máquina mágica revisa si la torre está bien.

- Si pones un bloque y la torre **se tambalea** (¡oh no!), pero **no lo arreglas** y sigues poniendo más bloques...
- ¡La torre puede caerse entera!
- **¿Qué es mejor?** Arreglar rápido el bloque flojo para que la torre siga fuerte y no se derrumbe.

## 🎁 Anti-patrón 2: Pensar que solo guardar los juguetes en la caja es suficiente

Imagina que tienes una caja mágica que **guarda automáticamente** todos tus juguetes cuando terminas de jugar.

- Pero la caja **no revisa** si los juguetes están **rotos o sucios**.
- Así que, la próxima vez que quieras jugar, algunos juguetes estarán rotos o sucios.
- **¿Qué es mejor?** Revisar y arreglar los juguetes antes de guardarlos, así la próxima vez están perfectos para jugar.

> 👉 De la misma forma, en la computadora **no basta** con guardar el programa automáticamente: ¡hay que revisarlo y probarlo para que funcione bien!

---
