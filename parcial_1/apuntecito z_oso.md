
# üõ†Ô∏è Ingenier√≠a de Software 2025  
## ‚úÖ Preguntas de Autoevaluaci√≥n ‚Äì Unidad 1  
> Recordar el principio **KISS**: *Keep It Simple, Stupid*  
> *(mantener las soluciones lo m√°s simples posible)*

---

### üìå [ ] 1. Definici√≥n de Ingenier√≠a del Software  
> **Instrucci√≥n:** Utilice menos de 100 palabras.

## üß† Ingenier√≠a de Software: Definici√≥n y Principios

Seg√∫n el material proporcionado, la **Ingenier√≠a de Software** es el uso de principios fundamentales de la ingenier√≠a con el objetivo de desarrollar software de forma **econ√≥mica, confiable y eficiente** en m√°quinas reales.  
Esta disciplina aplica un enfoque **sistem√°tico, disciplinado y cuantificable** al desarrollo, operaci√≥n y mantenimiento del software, siendo la aplicaci√≥n de la ingenier√≠a al software.  
Tambi√©n se define como la rama de las ciencias de la computaci√≥n que estudia la **creaci√≥n de software confiable y de calidad**, bas√°ndose en m√©todos y t√©cnicas de ingenier√≠a.  

> En esencia, busca desarrollar software de manera **eficiente y con calidad** [6].

### üèóÔ∏è Ingenier√≠a de Software: Planificaci√≥n y Calidad en el Desarrollo

Imaginen que construir una aplicaci√≥n o un programa es como **construir una casa**.  
La Ingenier√≠a de Software ser√≠a como **tener un plan detallado y organizado antes de empezar a poner ladrillos** [1, 2].  
En lugar de solo empezar a codificar sin pensar mucho, la ingenier√≠a de software se trata de aplicar ideas y m√©todos de la ingenier√≠a para hacer que ese programa sea **confiable, que funcione bien y que no cueste un ojo de la cara** [3-7].

Es como tener **reglas claras sobre c√≥mo se debe hacer el trabajo**, desde entender qu√© necesita el cliente hasta probar que todo funcione correctamente [2, 8].  
As√≠ nos aseguramos de que el software final sea de **buena calidad y sirva para lo que se cre√≥** [7, 9, 10].  

> En resumen, es la **manera inteligente y organizada** de construir software [9, 10].



---

### üìå [ ] 2. ¬øQu√© fue la crisis del software?  
> **Instrucci√≥n:** Utilice menos de 100 palabras.
## ‚ö†Ô∏è Pregunta 2 ‚Äì La Crisis del Software

La **crisis del software**, que surgi√≥ principalmente a finales de los a√±os 60, fue un periodo donde se hizo evidente la dificultad de la industria para desarrollar software que cumpliera con las expectativas y necesidades.  
Los proyectos de software frecuentemente **se entregaban tarde, exced√≠an el presupuesto y no funcionaban de manera fiable**.  
Esto se deb√≠a a problemas en la **definici√≥n y comprensi√≥n de los requisitos**, **mala planificaci√≥n y estimaci√≥n de costos**, y pr√°cticas de desarrollo ineficaces como el enfoque de *"codificar y corregir"*, que llevaba a **c√≥digo dif√≠cil de mantener**.  

La *creciente demanda de software m√°s complejo* superaba la *capacidad de las t√©cnicas existentes*.

### üßí Explicaci√≥n para un ni√±o de 5 a√±os

Imagina que queremos construir un juguete nuevo, como un robot.  
La **crisis del software** fue como cuando los constructores de juguetes **no sab√≠an bien c√≥mo hacer los robots** y **siempre se tardaban mucho en terminarlos**.  
A veces, **gastaban muchos materiales (como dinero)** y al final, ¬°el robot no hac√≠a lo que se supon√≠a que deb√≠a hacer o se romp√≠a muy f√°cil!  
Era como si empezaran a pegar piezas sin pensar mucho primero, y luego **todo quedaba desordenado** y era muy dif√≠cil arreglarlo si algo fallaba.

---

### üìå [ ] 3. Frase incompleta seg√∫n Pressman  
> Seg√∫n Pressman, para gestionar un proyecto hay que **______. las ______**. _____

## üìä Pregunta 3 ‚Äì Las 4 P de la Gesti√≥n de Proyectos

S√≠, seg√∫n el material proporcionado, para hacer una buena gesti√≥n de proyectos, hay que tener en cuenta y gestionar las **4 P**:  
üëâ **Personas**, **Proceso**, **Producto** y **Proyecto** [1-3].  
La fuente *"[Extra] Apunte - Primer Parcial.pdf"* [4] tambi√©n menciona que el principal inconveniente en la gesti√≥n de proyectos es el **control simult√°neo de las 4 P** (Personal, Producto, Proceso y Proyecto).

Las fuentes detallan la importancia de cada una de las 4 P en la gesti√≥n de proyectos:

### üë• Personas  
Son consideradas lo m√°s dif√≠cil de controlar [1, 2].  
Se enfatiza la importancia de **buscar miembros adecuados, retenerlos y motivarlos** [5].

### üîÅ Proceso  
La elecci√≥n del proceso **condiciona la manera de gestionar el proyecto y construir el producto** [1, 6].  
Es importante **definir el conjunto de tareas y actividades** a llevar a cabo [6].

### üì¶ Producto  
Lo primero es **determinar el √°mbito**, definiendo claramente qu√© se quiere lograr con el producto [1, 6].  
Es esencial que el producto **entregue valor** [6, 7].

### üìà Proyecto  
En un proyecto es obligatorio **controlar variables como Costo, Tiempo, Calidad y Alcance**, recomend√°ndose tener mayor cuidado con el **alcance** [1, 7].


Por lo tanto, la afirmaci√≥n de que hay que controlar las **4 P (Personas, Proceso, Producto y Proyecto)** para gestionar un proyecto est√° respaldada por el material proporcionado [1-4].

### üë∂ Explicaci√≥n para un ni√±o de 5 a√±os

Imagina que est√°s jugando a construir algo con bloques. Para que tu construcci√≥n quede bien, necesitas pensar en **cuatro cosas**, como si fueran cuatro amigos que te ayudan:

- üßë‚Äçü§ù‚Äçüßë **Amigo Persona**: Son los ni√±os que van a construir. Tienes que ver si todos est√°n contentos y saben qu√© hacer para que trabajen bien juntos.  
- üîß **Amigo Proceso**: Son los pasos que van a seguir para construir. Primero poner la base, luego las paredes, luego el techo. Si siguen los pasos en orden, es m√°s f√°cil que no se equivoquen.  
- üè∞ **Amigo Producto**: Es lo que quieren construir al final, ¬°el castillo, la nave espacial! Tienen que saber bien qu√© quieren hacer para no construir otra cosa sin querer.  
- üóìÔ∏è **Amigo Proyecto**: Es todo el plan para construir. Cu√°ntos bloques tienen, cu√°nto tiempo tienen para terminar, si el castillo tiene que ser muy alto o m√°s bajito.

Para que tu construcci√≥n salga bien, tienes que estar atento y cuidar a estos cuatro amigos.  
Si un amigo no est√° bien, ¬°el castillo se puede caer!  
Por eso, los ingenieros de software tambi√©n tienen que cuidar y estar atentos a estas **cuatro cosas** cuando hacen programas para la computadora.


---

### üìå [ ] 4. ¬øQu√© es un proceso?  
> **Instrucci√≥n:** Utilice menos de 50 palabras.

## üîÑ Pregunta 4 ‚Äì Definici√≥n de Proceso en Ingenier√≠a de Software

Seg√∫n el material proporcionado, un **proceso** en Ingenier√≠a de Software es un:

> üîß **Conjunto de actividades, acciones y tareas que se ejecutan para crear un producto** [1, 2].

Este proceso **define una estructura** para lograr la obtenci√≥n eficaz de tecnolog√≠a dentro del desarrollo de software [1, 2].  
Adem√°s, tambi√©n se describe como:

> üõ†Ô∏è **Un conjunto de actividades para desarrollar o mantener software y sus productos asociados** [3, 4].

En resumen, el proceso es **la manera organizada en la que trabajamos** para lograr que el software funcione correctamente, cumpla con los objetivos y se pueda mantener en el tiempo.

### üë∂ Explicaci√≥n para un ni√±o de 5 a√±os

Imagina que quer√©s hacer una torta üéÇ.  
Para que salga rica, no pod√©s simplemente mezclar todo al azar.  
Ten√©s que seguir **una receta**, paso a paso:  
primero mezclar los ingredientes, despu√©s poner la mezcla en el molde, prender el horno, y as√≠.

El **proceso en software** es como esa receta, pero en vez de hacer una torta, **hacemos programas para la compu**.  
Los programadores siguen **una serie de pasos ordenados** para que todo funcione bien y no se olviden de nada importante.

Si no segu√≠s la receta, la torta puede salir mal...  
¬°y con el software pasa lo mismo!


---

### üìå [ ] 5. Diferencias entre procesos predictivos y emp√≠ricos  
> ¬øEn cu√°l se enmarca la agilidad?

## üîÅ Pregunta 5 ‚Äì Control Predictivo vs. Control Emp√≠rico

### üß† Definici√≥n t√©cnica

Seg√∫n el material proporcionado:

- En los **procesos de control predictivo**, las variables del proyecto se **identifican claramente, se controlan y su comportamiento se puede predecir** [1, 2].
  - Se inspiran en las l√≠neas de producci√≥n.
  - Se basa en que **siempre que sigas el mismo proceso, vas a obtener el mismo resultado** [1, 2, 3].
  - Ejemplo cl√°sico: el **modelo en cascada** [1].

- En cambio, los **procesos de control emp√≠ricos** aceptan que **no todo se puede predecir ni controlar**, sobre todo por la **complejidad del software** [2, 4, 5].
  - Se mide constantemente lo que se va construyendo.
  - Se adapta el trabajo seg√∫n lo que se ve y se necesita.
  - Ejemplo cl√°sico: **metodolog√≠as √°giles** como Scrum [4, 6].

### üè† Ejemplo pr√°ctico: Construir una casa para un perro

#### üõ†Ô∏è Proceso Predictivo
1. Dibuj√°s un plano muy detallado desde el principio: medidas, materiales, c√≥mo poner cada clavo [1, 3].
2. Constru√≠s siguiendo el plan **sin cambios**.
3. Al final mostr√°s la casa terminada al due√±o [7].
4. Si no le gusta, **cambiar algo cuesta mucho trabajo** [8].

#### üîÑ Proceso Emp√≠rico
1. Ten√©s una idea general (una casita con puerta) [2].
2. Hac√©s la base y una pared, y **mostr√°s al due√±o** c√≥mo va quedando.
3. Si el due√±o quiere cambiar algo (como mover la puerta), **adapt√°s el plan** [2, 9].
4. Repet√≠s el ciclo hasta terminar la casa que **seguro le gusta al perro** [9].

### üë∂ Explicaci√≥n para un ni√±o de 5 a√±os

#### ‚òÄÔ∏è Dibujar un sol

- **Control Predictivo**:  
  Dibuj√°s un sol perfecto de una vez: primero el c√≠rculo, luego todos los rayitos iguales.  
  Pero si quer√≠as ponerle una carita y te olvidaste‚Ä¶ ¬°es dif√≠cil de agregar al final!

- **Control Emp√≠rico**:  
  Dibuj√°s un c√≠rculo y le pregunt√°s a tu mam√° si parece un sol.  
  Ella dice: ‚Äú¬°S√≠, pero le faltan rayitos!‚Äù. Dibuj√°s los rayitos.  
  Luego ella dice: ‚Äú¬°Qu√© lindo! ¬øY si le pon√©s una carita feliz?‚Äù.  
  ¬°Entonces la dibuj√°s! As√≠ lo hac√©s paso a paso, cambiando seg√∫n lo que te dicen üòä.



---

### üìå [ ] 7. Beneficio de un ciclo de vida √°gil vs. en cascada  
> Incluya tambi√©n riesgos y costes.
## üîÅ Pregunta 7 ‚Äì Agilidad vs. Cascada: Beneficios, Riesgos y Costos

### üöÄ Beneficios de un ciclo de vida √°gil vs. uno en cascada

Seg√∫n "[Extra] Apunte - Primer Parcial.pdf" y otros documentos [1‚Äì4]:

- **üì¶ Entregas r√°pidas y funcionales**: Se entrega software que funciona cada pocas semanas, generando valor temprano [1, 5].
- **üëÇ Validaci√≥n temprana con el cliente**: Se verifica r√°pidamente si el producto satisface al usuario final, reduciendo el riesgo de construir "lo equivocado" [1, 2].
- **üìÑ Menos documentaci√≥n innecesaria**: Se prioriza el software funcionando sobre la burocracia documental [1, 5].
- **‚è≥ Mejor estimaci√≥n del tiempo restante**: Cada iteraci√≥n permite ajustar con m√°s precisi√≥n la estimaci√≥n del tiempo total del proyecto [1, 6, 7].
- **ü§ù Mejor interacci√≥n en el equipo**: Favorece la colaboraci√≥n y comunicaci√≥n constante [1, 8].
- **üîÅ Buena respuesta al cambio**: Se aceptan y se adaptan los cambios, incluso en etapas avanzadas del desarrollo [1, 5, 9].
- **‚ùå Menor riesgo de cancelaci√≥n**: El cliente ve valor de manera continua y no pierde el inter√©s [2].
- **üí∞ Menor costo de los cambios**: Especialmente si se detectan temprano; la agilidad busca **mantener los costos de cambio bajos** a lo largo del tiempo [2, 10‚Äì13].

### ‚ö†Ô∏è Riesgos

- **Agilidad reduce riesgos** como:
  - Construir algo que el cliente no necesita [2].
  - Que el cliente pierda el inter√©s por falta de avances visibles [2].

- En proyectos grandes, **la agilidad mal gestionada puede aumentar los costos** si se hacen muchos cambios sin control [14].

### üí∏ Costos

- **Menores costos de cambio** en comparaci√≥n con cascada [2].
- **Evita documentaci√≥n innecesaria**, reduciendo tambi√©n tiempo y esfuerzo [1].
- En cascada, los cambios **tard√≠os son muy costosos**. En √°gil, se busca **invertir la curva de costos de cambio** [15].


### üè∞ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyamos un castillo de arena!

#### üåä En cascada:
1. Dibuj√°s todo el castillo con torres y puertas antes de empezar [16].
2. Lo hac√©s todo sin mostrar nada hasta el final.
3. Cuando termin√°s, tu amigo lo ve y dice:  
   **"¬°No me gusta la puerta!"**  
   Pero ahora cambiarla **cuesta mucho trabajo** o hay que **romperlo** üòì [1, 15, 16].

#### üß± Con agilidad:
1. Hac√©s una torre chiquita y se la mostr√°s a tu amigo.
2. √âl dice: **"¬°Qu√© bien!"**
3. Hac√©s una muralla, y tu amigo dice: **"Pon√© la puerta ac√°"**, y vos **la cambi√°s f√°cil** üß†.
4. Constru√≠s paso a paso y siempre le pregunt√°s si le gusta.
5. Si hay que cambiar algo, **no es grave** y todos est√°n contentos üòä.

As√≠, tu amigo no se aburre y el castillo sale como √©l lo quiere ‚ù§Ô∏è.


---

### üìå [ ] 8. Gesti√≥n de Proyectos de Software  
> ¬øQu√© entiende por gesti√≥n de proyectos?  
> Mencione los pilares para que sea eficaz.

## üèóÔ∏è Pregunta 8 ‚Äì Gesti√≥n de Proyectos de Software: Las 4 Ps

### üìã ¬øQu√© es la Gesti√≥n de Proyectos de Software?

Es el conjunto de actividades para **planificar, supervisar y controlar**:
- Al personal,
- Los procesos,
- Los eventos,
- Y el producto en s√≠,

durante **todo el ciclo de vida del software**, desde la idea inicial hasta su implementaci√≥n operativa [1‚Äì3].

Tambi√©n incluye el **mantenimiento**, que puede convertirse en un nuevo proyecto en s√≠ mismo [2, 3].

---

### üîë Las 4 Ps de la Gesti√≥n de Proyectos

Una gesti√≥n eficaz se basa en **cuatro pilares fundamentales**:

#### üë• 1. Personal
- El equipo humano es clave.
- Hay que saber **atraer, formar, motivar, organizar y retener** al personal necesario para cumplir los objetivos [4, 6].

#### üß± 2. Producto
- Se definen los **objetivos y el alcance** del producto.
- Se consideran **alternativas de soluci√≥n** y se identifican **restricciones t√©cnicas y administrativas** [6‚Äì8].

#### üß≠ 3. Proceso
- El proceso act√∫a como **marco conceptual** para crear el plan de desarrollo [6, 7, 9].
- Debe ser **elegido por el equipo**, ya que define c√≥mo se gestionar√° y construir√° el producto [7, 9].

#### üìÜ 4. Proyecto
- Es la **planificaci√≥n y el control** de todo el trabajo necesario.
- Implica organizar tiempos, recursos, tareas y objetivos con un prop√≥sito espec√≠fico [10].

---

### ‚ö†Ô∏è Dificultades
El mayor desaf√≠o es **coordinar simult√°neamente** las 4 Ps:
- No siempre se sabe con certeza **qu√© hay que hacer** ni **qui√©n debe hacerlo** desde el inicio del proyecto [10].

---

### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyamos un castillo de bloques!

Gestionar el proyecto es como ser el **jefe constructor** del castillo:

#### Las 4 Ps son como ingredientes secretos para que todo salga bien:

- **üë´ Personas (Amigos):** Necesit√°s amigos que te ayuden a poner los bloques y que se diviertan haci√©ndolo.
- **üè∞ Producto (Castillo):** Decid√≠s qu√© castillo quer√©s. ¬øVa a tener torres? ¬øPuente levadizo?
- **üî® Proceso (C√≥mo construir):** Pens√°s c√≥mo lo van a hacer. ¬øPrimero la base? ¬øCada uno hace una parte?
- **üóìÔ∏è Proyecto (Toda la construcci√≥n):** Te asegur√°s de que nadie se olvide qu√© hacer, que haya suficientes bloques, y que terminen a tiempo.

Ser el jefe no es f√°cil, porque ten√©s que pensar en **todo al mismo tiempo**. Pero si lo hac√©s bien, ¬°el castillo queda incre√≠ble! üòÑ



---

### üìå [ ] 9. Organigramas y equipos √°giles  
> ¬øCu√°l organigrama se parece m√°s a un equipo √°gil?  
> Justifique en menos de 100 palabras.

## ü§ù Pregunta 9 ‚Äì Equipos √Ågiles: Liderazgo Gu√≠a y Decisi√≥n Colectiva

### üåÄ ¬øC√≥mo funciona el liderazgo en los equipos √°giles?

En los equipos √°giles, el **liderazgo no se basa en la autoridad**, sino en la **gu√≠a y acompa√±amiento**.

- El l√≠der **no toma las decisiones por el equipo** [1, 2].
- Su funci√≥n principal es **facilitar, motivar y ayudar al equipo** a alcanzar su mejor rendimiento.

---

### üë• ¬øC√≥mo son los equipos √°giles?

Los equipos √°giles tienen las siguientes caracter√≠sticas clave:

- Son **peque√±os**, **autoorganizados** y **multifuncionales** [3‚Äì8].
- **Las decisiones se toman en grupo**, a trav√©s del **consenso**.
- Hay **interacci√≥n constante** entre todos los miembros.

Este enfoque se corresponde con:

- El **paradigma aleatorio y abierto** [9, 10].
- El **organigrama Descentralizado Democr√°tico (DD)** [11], donde:
  - No hay un jefe permanente,
  - La comunicaci√≥n es horizontal,
  - Las decisiones son consensuadas entre todos.

### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Jugamos a construir con Legos!

Imagin√° que est√°s con tus amigos construyendo con Legos. En vez de que uno solo diga qu√© hacer, **todos se sientan y deciden juntos** qu√© van a construir [4, 6].

Hay un amigo que **no manda**, sino que **ayuda a que todos se pongan de acuerdo** y trabajen bien juntos [1, 2].

Cada amigo tiene una habilidad especial, como una **banda de superh√©roes** donde todos hacen algo importante [7, 12].

As√≠, construyen algo genial y se divierten trabajando como un verdadero **equipo**. üí™

---

### üìå [ ] 10. Caso hist√≥rico: soluci√≥n de una d√©cada a otra  
> Mencione un caso en la historia de la ingenier√≠a de software.


## üõ†Ô∏è Pregunta 10 ‚Äì Evoluci√≥n de la Ingenier√≠a de Software: 1970s a 1980s

### üï∞Ô∏è ¬øQu√© pas√≥ en la ingenier√≠a de software entre los 70s y los 80s?

#### **Los a√±os 70: Formalidad y procesos en cascada**

En los a√±os 70, la ingenier√≠a de software segu√≠a un modelo muy **formal y estructurado** que estaba inspirado en la **ingenier√≠a de hardware** [1‚Äì3]. Se introdujeron conceptos clave como:

- **Ingenier√≠a de requisitos**: Definir qu√© debe hacer el software antes de empezar a programar.
- **Dise√±o como etapa previa a la programaci√≥n**: Antes de escribir c√≥digo, se dise√±aba el sistema [1‚Äì6].
- **Programaci√≥n estructurada**: Ideas de cohesi√≥n y acoplamiento para mejorar la organizaci√≥n del c√≥digo [1‚Äì6].

Sin embargo, este enfoque gener√≥ varios problemas:

- Los **m√©todos formales** eran dif√≠ciles de usar por muchos programadores.
- El **modelo en cascada** era lento, costoso y requer√≠a mucha **documentaci√≥n** [3, 7, 8].
- Las **organizaciones excedieron los costos** de hardware, y se comenz√≥ a preocupar por mejorar la **productividad del software** [7, 8].

#### **Los a√±os 80: Soluciones y avances**

En los a√±os 80, comenzaron a surgir **iniciativas para mejorar la productividad y escalabilidad** en la ingenier√≠a de software [3, 8, 9]. Algunos de los avances fueron:

- Se busc√≥ **evitar la etapa de pruebas** para reducir costos, y se progres√≥ en **herramientas de testing** y **gesti√≥n de configuraci√≥n** [3, 10].
- **Programaci√≥n Orientada a Objetos (POO)**: Un nuevo enfoque que permiti√≥ organizar el c√≥digo de manera m√°s eficiente.
- Se introdujeron **herramientas CASE** para automatizar partes del proceso de desarrollo [3, 10‚Äì13].
- Se **mejor√≥ la reutilizaci√≥n de software**, lo que ayud√≥ a reducir trabajo repetitivo y racionaliz√≥ el desarrollo [3, 9, 11, 13‚Äì15].
- Aparecieron modelos para **estandarizar los procesos**, como el **modelo de madurez de la capacidad de software (CMM)** [3, 16‚Äì18].

---

### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo Juguetes!

Imagina que en los a√±os 70, construir un juguete era como seguir un **libro de instrucciones muy largo y complicado** con dibujos peque√±os y muchas reglas [1, 19, 20]. A veces, las reglas eran tan dif√≠ciles que **nadie entend√≠a c√≥mo seguir** construyendo, y **tardaban mucho** en terminar el juguete [7, 8].

En los a√±os 80, la gente pens√≥ que ser√≠a mejor tener **instrucciones m√°s f√°ciles** y usar **piezas que ya ten√≠an hechas** de otros juguetes para **construir m√°s r√°pido** [9, 11, 14]. Tambi√©n inventaron **cajas de herramientas** especiales para **guardar y encontrar las piezas m√°s f√°cilmente** [10]. 

As√≠, **construir juguetes** se volvi√≥ **m√°s r√°pido y menos complicado**. üß∏‚ö°


---

### üìå [ ] 11. Rol de manager: formaci√≥n de equipo √°gil  
> ¬øQu√© aspectos y factores deber√≠a tener en cuenta?

## üõ†Ô∏è Pregunta 11 ‚Äì Formando Equipos √Ågiles: Gu√≠a Concisa

### ü§ù ¬øQu√© tener en cuenta al formar un equipo de software √°gil?

#### **Aspectos clave para formar un equipo √°gil:**

1. **Tama√±o del equipo**: El equipo debe ser peque√±o, idealmente entre **3 y 7 personas**, para facilitar la comunicaci√≥n y la toma de decisiones. Un equipo peque√±o ayuda a llegar a un consenso m√°s f√°cilmente [1‚Äì4].

2. **Multifuncionalidad**: Es esencial que el equipo sea **multifuncional**, es decir, que cada miembro tenga habilidades variadas para realizar el trabajo sin depender de otros equipos. Esto implica tener expertos en cada √°rea y otros dispuestos a aprender [1, 4‚Äì8].

3. **Autoorganizaci√≥n**: El equipo debe ser **autoorganizado**, con la capacidad de tomar decisiones por consenso y ser responsable de ellas. Mi rol como manager ser√≠a m√°s de **gu√≠a** que de tomar decisiones por el equipo [2, 5, 7, 9‚Äì14].

4. **Motivaci√≥n y retenci√≥n del personal**: Buscar a los miembros m√°s adecuados, motivarlos y mantenerlos, creando un entorno de trabajo productivo [1, 3, 17, 18].

5. **Madurez t√©cnica**: El equipo debe ser **t√©cnicamente maduro**, entendiendo el impacto de la no calidad [1, 3, 12, 19, 20].

6. **Comunicaci√≥n y colaboraci√≥n**: Fomentar una constante **interacci√≥n y comunicaci√≥n** entre los miembros, con decisiones tomadas en consenso. La **comunicaci√≥n cara a cara** es muy eficaz [4, 5, 8, 10, 15, 21].

7. **Inclusi√≥n de roles necesarios**: Asegurarme de que el equipo incluya todos los **roles necesarios** (como testers), integrados dentro del propio equipo [6, 23].

8. **Alineaci√≥n con los valores √°giles**: Buscar personas cuyas **valores no negociables** coincidan con los del equipo y con los principios √°giles [24‚Äì26].

9. **Estabilidad del equipo**: Intentar mantener al equipo junto el mayor tiempo posible para mejorar la **estimaci√≥n** y el **rendimiento** [27].


### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo con Legos!

Imagina que vamos a formar un equipo de **constructores de Legos** muy r√°pido y divertido:

- **Pocos amigos**: Necesitamos pocos amigos en el equipo, como t√∫ y algunos m√°s, ¬°no much√≠simos! As√≠ podemos hablar mejor y decidir r√°pido qu√© construir [1, 2].
- **Amigos que saben muchas cosas**: Cada amigo debe ser bueno en algo diferente con los Legos, como uno sabe hacer torres, otro sabe hacer puentes, y otro tejados. As√≠ no necesitamos llamar a otros ni√±os para que nos ayuden [1, 5].
- **Todos deciden**: Todos los amigos juntos van a decidir qu√© vamos a construir y c√≥mo lo vamos a hacer. Yo, como el mayor, solo les ayudar√© a que se pongan de acuerdo y a que tengan todos los Legos que necesiten [5, 9].
- **Amigos contentos**: Quiero que mis amigos est√©n contentos y con ganas de construir [1].
- **Amigos que construyen bien**: Mis amigos deben saber c√≥mo encajar bien las piezas para que el castillo no se caiga [1].
- **Hablar mucho**: Tenemos que hablar mucho entre nosotros para saber qu√© est√° haciendo cada uno y si necesitamos ayuda [15].
- **Todos ayudan en todo**: Si necesitamos probar si la puerta se abre bien, todos podemos intentarlo, no solo un amigo especial [23].
- **Amigos que les gusta trabajar as√≠**: Quiero amigos a los que les guste construir r√°pido y cambiar las cosas si no quedan bien [24, 25].
- **El mismo equipo siempre**: Si siempre construimos con los mismos amigos, ¬°cada vez lo haremos mejor y m√°s r√°pido! [27].



---

### üìå [ ] 12. Ingenier√≠a de Software en los a√±os 50  
> ¬øCu√°l fue su principal caracter√≠stica?

## üõ†Ô∏è Pregunta 12 ‚Äì Ingenier√≠a de Software: Paralelismos con el Hardware en los A√±os 50

### üñ•Ô∏è ¬øC√≥mo se ve√≠a la ingenier√≠a de software en los a√±os 50?

En la d√©cada de 1950, la **Ingenier√≠a de Software** estaba muy influenciada por la ingenier√≠a de **hardware**. Los ingenieros pensaban que el software se pod√≠a desarrollar de la misma forma que el hardware, utilizando los mismos principios y enfoques [1‚Äì4]. Esto se deb√≠a a que el costo del **hardware** era mucho mayor que el del software, y los ingenieros de software tambi√©n trabajaban a menudo en el desarrollo de hardware [3]. 

Se cre√≠a que el software deb√≠a ser muy **preciso** y **detallado**, con especificaciones largas y complejas. La filosof√≠a era similar a la de "medir dos veces, cortar una" [4], lo que implicaba que hab√≠a que planificar cada parte del software con mucho cuidado antes de implementarla.


### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo un coche de juguete!

Imagina que queremos construir un **coche de juguete**. En los a√±os 50, la gente pensaba que hacer programas para las computadoras era igual que **construir partes del coche**, como las ruedas o el motor [6]. Cre√≠an que hab√≠a que planificarlo todo muy bien, como si fueran piezas de **metal** [4]. Era como si pensaran que hacer un programa era como **armar un rompecabezas** muy grande y complicado, pieza por pieza, igualito a c√≥mo se construye un objeto de verdad [3].


---

### üìå [ ] 13. Inconvenientes en los a√±os 60 o 70  
> Explique mediante un ejemplo.

## üõ†Ô∏è Pregunta 13 ‚Äì Ingenier√≠a de Software en los A√±os 60: Codificar y Corregir

### üñ•Ô∏è ¬øC√≥mo era la ingenier√≠a de software en los a√±os 60?

En los a√±os 60, la ingenier√≠a de software comenz√≥ a mostrar sus inconvenientes con el enfoque llamado "codificar y corregir" [1, 2]. Aunque ya exist√≠an avances tecnol√≥gicos, qued√≥ claro que el software no pod√≠a tratarse como el hardware. En lugar de realizar una planificaci√≥n exhaustiva antes de comenzar, se prefer√≠a **comenzar a programar** y luego corregir los errores a medida que surg√≠an [1, 3].

Este enfoque dio lugar a lo que se conoce como "**c√≥digo espagueti**", un c√≥digo desordenado y dif√≠cil de entender, incluso para la persona que lo hab√≠a escrito [4]. Esto hac√≠a que **encontrar errores** fuera muy complicado y consumiera mucho tiempo [2]. Adem√°s, mantener y actualizar este software se volvi√≥ muy complicado, ya que cualquier cambio pod√≠a generar nuevos problemas en otras partes del c√≥digo [5]. Durante este tiempo, el desarrollo de software depend√≠a a menudo de programadores que trabajaban muchas horas extra para solucionar problemas de √∫ltimo minuto [2, 4].


### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo una torre de bloques!

Imagina que quieres construir una **torre de bloques** muy alta, pero en lugar de pensar bien c√≥mo hacerlo primero, solo comienzas a poner bloques uno encima del otro sin un plan [2]. Al principio puede que la torre suba, pero si pones los bloques sin cuidado, ¬°la torre se tambalear√° y ser√° dif√≠cil poner m√°s bloques encima [4]!

Si quieres cambiar algo abajo, ¬°todo lo de arriba puede caerse! [5].

En los a√±os 60, a veces **constru√≠an programas de computadora** as√≠, sin mucho pensar primero [2]. El c√≥digo era como una torre de bloques desordenada y si hab√≠a un error, era muy dif√≠cil encontrarlo y arreglarlo sin que se rompiera otra parte [4]. Solo una persona muy lista que conoc√≠a todos los bloques enredados pod√≠a arreglarlo si se ca√≠a [2, 4].



---

### üìå [ ] 14. Inconvenientes de la gesti√≥n cl√°sica  
> Explique con sus palabras.

## ‚ö†Ô∏è Pregunta 14 ‚Äì Desventajas de la Gesti√≥n Cl√°sica en Software

### üñ•Ô∏è ¬øCu√°les son las desventajas de la gesti√≥n cl√°sica en la ingenier√≠a de software?

Los modelos cl√°sicos de gesti√≥n de proyectos en ingenier√≠a de software presentan varias desventajas clave:

1. **Rigidez y dificultad para adaptarse a los cambios**: Modelos como el de cascada siguen un flujo secuencial donde una etapa debe completarse antes de pasar a la siguiente [1-6]. Esto dificulta la incorporaci√≥n de cambios en los requerimientos una vez que el proyecto avanza, generando confusi√≥n y retrasos [3, 6].

2. **Entrega tard√≠a del producto funcional**: En modelos cl√°sicos como el cascada, no se dispone de una versi√≥n funcional del software hasta las etapas finales [3, 6, 7], lo que impide obtener retroalimentaci√≥n temprana y detectar errores importantes a tiempo [3, 7, 8].

3. **Suposici√≥n de requisitos estables y bien definidos**: Los modelos cl√°sicos asumen que los requisitos del cliente son claros desde el inicio, pero en la pr√°ctica estos pueden evolucionar durante el desarrollo [3, 6, 9].

4. **Estados de bloqueo y baja interacci√≥n**: Al ser secuencial, los miembros del equipo a menudo deben esperar a que otros terminen su parte del trabajo, lo que disminuye la productividad [7, 10]. Adem√°s, los equipos son grandes y suelen tener poca interacci√≥n [2, 11-13].

5. **Enfoque intenso en la documentaci√≥n**: Los modelos cl√°sicos requieren mucha documentaci√≥n en cada etapa [2, 14-16], lo que puede resultar lento y costoso [14, 15].

6. **Dificultad en la estimaci√≥n**: Estimar los costos y tiempos de un proyecto desde el principio es un reto importante [17-21].

7. **Control simult√°neo de las 4 P**: Los modelos cl√°sicos intentan controlar simult√°neamente las Personas, el Proceso, el Producto y el Proyecto, lo cual a menudo es muy dif√≠cil de lograr [12, 22-34].

### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo un castillo de arena!

Imagina que quieres construir un **castillo de arena muy grande** siguiendo un dibujo muy detallado que hiciste al principio [1, 2].

1. **Reglas estrictas**: Si quieres cambiar algo de tu castillo, como hacerlo m√°s alto o moverlo a otro lugar, ¬°es muy dif√≠cil! [3, 6] Tienes que seguir el dibujo original aunque ya no te guste tanto.

2. **Castillo al final**: No ver√°s c√≥mo va quedando el castillo hasta que est√© casi listo [3, 6, 7]. Si no queda bien o algo est√° mal hecho, tendr√°s que deshacer mucho trabajo.

3. **Todos esperan**: A veces, los amigos tienen que esperar a que los dem√°s terminen de hacer su parte, como las torres o las banderas [7, 10]. ¬°Eso hace que tarde m√°s en terminarse!

4. **Muchos papeles**: Tienes que dibujar muchos planos y escribir muchas cosas antes de empezar a construir [2, 14, 16]. ¬°A veces ser√≠a m√°s divertido simplemente empezar a construir!

5. **Adivinar cu√°nto tiempo nos llevar√°**: Al principio, tienes que adivinar cu√°nto tiempo tardar√°s en hacer todo el castillo, pero puede ser dif√≠cil porque es muy grande y complicado [17, 19, 21].

Es como si tuvi√©ramos un plan muy fijo y no pudi√©ramos cambiarlo mucho, y solo ver√≠amos el resultado final mucho despu√©s. A veces, es mejor construir poco a poco y ver si nos gusta para poder cambiar las cosas si es necesario.



---

### üìå [ ] 15. Modelo de proceso emp√≠rico con un antipatr√≥n  
> Ejemplo que ilustre una caracter√≠stica del modelo emp√≠rico usando un antipatr√≥n.

## ‚ö†Ô∏è Pregunta 15 ‚Äì Antipatrones, Cohesi√≥n, Acoplamiento y Procesos Emp√≠ricos

### üñ•Ô∏è ¬øQu√© son los antipatr√≥nes, la cohesi√≥n, el acoplamiento y c√≥mo se relacionan con los procesos emp√≠ricos?

- **Antipatr√≥n**: Es una soluci√≥n com√∫n a un problema recurrente que parece efectiva al principio, pero que con el tiempo genera m√°s problemas y dificultades [1].
- **Modelo de proceso emp√≠rico**: En este enfoque de desarrollo de software, se da importancia a la **experiencia**, la **experimentaci√≥n** y la **adaptaci√≥n continua**. Acepta que los requisitos pueden cambiar y que no todo se puede predecir desde el principio [2]. Los ciclos cortos de trabajo, la entrega frecuente de software y la retroalimentaci√≥n constante son clave para adaptarse al cambio [2].
  
Un **modelo emp√≠rico** se enfoca en la capacidad de **adaptaci√≥n al cambio** [2]. 

- **Cohesi√≥n** *(Relaciones entre modulos)*: Se refiere a la *relaci√≥n entre las diferentes partes de un m√≥dulo de software*. **Baja cohesi√≥n** ocurre cuando las partes de un m√≥dulo no est√°n claramente relacionadas entre s√≠ [5]. Es como tener cosas que no tienen nada que ver dentro de una misma caja.
- **Acoplamiento** *(Dependencia entre modulos)*: Se refiere a c√≥mo las partes de un software dependen unas de otras. **Alto acoplamiento** ocurre cuando las partes est√°n muy interconectadas y dependen mucho unas de otras, lo que hace que cambiar una parte pueda romper otras [4, 5]. Es como tener bloques de Lego pegados con mucha cola; al intentar mover uno, toda la torre se cae.

En un **modelo emp√≠rico**, **baja cohesi√≥n** y **alto acoplamiento** son antipatr√≥nes, ya que dificultan la adaptaci√≥n al cambio. Si el sistema es complicado de modificar debido a la interdependencia entre partes, el equipo pierde tiempo tratando de entender los impactos de los cambios y corrigiendo problemas, en lugar de avanzar con nuevas funcionalidades [5, 6, 7].

---

### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo un castillo de arena!

Imagina que estamos construyendo un **castillo de arena con muchos cuartos**.

- **Antipatr√≥n**: Es como si cada cuarto tuviera **much√≠simas cosas diferentes** que no tienen nada que ver entre s√≠ (baja cohesi√≥n). Y adem√°s, todos los cuartos estuvieran conectados por **much√≠simos t√∫neles secretos**. Si tocas una cosa en un cuarto, ¬°todo se rompe en otro cuarto lejano! (alto acoplamiento).

- **Proceso Emp√≠rico**: Queremos construir el castillo poquito a poquito. Mostramos a nuestro amigo lo que hemos hecho y, si quiere que cambiemos algo, como a√±adir una torre o mover una muralla, ¬°queremos que sea f√°cil hacerlo!

- **El problema del antipatr√≥n**: Pero si nuestro castillo tiene los cuartos llenos de cosas sin sentido y todos los t√∫neles secretos, cuando nuestro amigo nos pida una torre m√°s grande, ¬°ser√° muy dif√≠cil cambiarla sin que se caigan otras partes del castillo! Tendremos que tener mucho cuidado, tomar√° mucho tiempo y, ¬°quiz√°s rompamos algo m√°s sin querer! 

Es mejor que cada cuarto tenga cosas que **s√≠ tengan que ver entre s√≠** y que no est√©n todos **tan pegados** para poder cambiar el castillo f√°cilmente.


---

### üìå [ ] 16. Selecci√≥n del ciclo de vida adecuado  
> Principales factores y caracter√≠sticas a tener en cuenta.

## ‚öôÔ∏è Pregunta 16 ‚Äì Selecci√≥n del Ciclo de Vida de Desarrollo de Proyectos

### üñ•Ô∏è ¬øC√≥mo se selecciona el ciclo de vida adecuado para el desarrollo de un proyecto?

La selecci√≥n del ciclo de vida adecuado depende de diversos factores relacionados con las caracter√≠sticas y necesidades del proyecto. A continuaci√≥n se presentan los principales aspectos a considerar:

- **Comprensi√≥n y estabilidad de los requerimientos**: Si los requerimientos son estables y bien comprendidos desde el inicio, un modelo secuencial como el modelo en cascada podr√≠a ser adecuado [1-4]. Sin embargo, si los requerimientos cambian con frecuencia, se deben considerar modelos evolutivos, de prototipado o √°giles [6-10].
  
- **Riesgo del proyecto**: Para proyectos con alto riesgo, el **modelo en espiral** es √∫til para reducir los riesgos de manera incremental, utilizando prototipos [12, 13]. Los enfoques tradicionales realizan un an√°lisis de riesgos al inicio, mientras que los m√©todos √°giles lo hacen de manera iterativa [17-19].

- **Necesidad de entrega temprana de funcionalidades**: Los modelos **incrementales** o **evolutivos** permiten entregar versiones tempranas del software, y los m√©todos √°giles se centran en entregar r√°pidamente funcionalidades [6, 8, 20-23].

- **Tama√±o y complejidad del proyecto**: Los m√©todos √°giles son m√°s adecuados para proyectos peque√±os [11], mientras que proyectos grandes pueden beneficiarse de un enfoque **incremental o en espiral** [12, 13, 20].

- **Estabilidad del entorno del proyecto**: En entornos inestables o con cambios r√°pidos en los requisitos, los m√©todos √°giles son m√°s apropiados. Para entornos m√°s estables, los m√©todos secuenciales son m√°s aplicables [2, 4, 10].

- **Costo de modificaci√≥n del producto**: Si modificar el producto es costoso, los enfoques √°giles pueden no ser apropiados. La curva de Boehm muestra que los costos de cambio son m√°s bajos durante las fases de an√°lisis y dise√±o [25-28].

- **Cultura organizacional y del equipo**: Si la organizaci√≥n favorece la interacci√≥n entre las personas sobre los procesos, los m√©todos √°giles pueden ser m√°s efectivos, ya que promueven equipos peque√±os y autoorganizados [29-32].

- **Cumplimiento con est√°ndares y normas de calidad**: Si es necesario cumplir con normativas estrictas, un enfoque predictivo puede ser m√°s adecuado. Sin embargo, los m√©todos √°giles tambi√©n enfocan la calidad de manera constante [10, 24, 33].

- **Valor del usuario y retorno de la inversi√≥n (ROI)**: Los m√©todos √°giles priorizan la entrega de funcionalidades que aporten mayor valor al cliente [34-37].

- **Criticidad y confiabilidad del software**: Para proyectos cr√≠ticos, es necesario un enfoque que enfatice la prevenci√≥n y eliminaci√≥n temprana de errores [38-40].


### üß∏ Explicaci√≥n para un ni√±o de 5 a√±os: ¬°Construyendo un robot!

Imagina que queremos construir un **robot nuevo**. ¬øC√≥mo decidimos la mejor forma de hacerlo?

- **Modelo Cascada**: Si sabemos exactamente c√≥mo queremos que sea el robot y no vamos a cambiar de idea, seguimos un dibujo paso a paso, haciendo una cosa tras otra.

- **Modelos Incrementales o √Ågiles**: Si no estamos seguros de c√≥mo queremos el robot, podemos construir un brazo primero, luego una pierna, y ver c√≥mo funciona antes de seguir construyendo. As√≠ lo hacemos poquito a poco.

- **Modelo en Espiral**: Si el robot es muy importante, como uno que explora el espacio, tenemos que tener mucho cuidado. Primero planeamos, construimos un poquito, probamos mucho, y luego repetimos este proceso.

- **Modelo de Prototipado**: Si queremos ver c√≥mo se ve el robot r√°pido, podemos hacer un dibujo r√°pido o un modelo sencillo con plastilina, y ense√±√°rselo a nuestro amigo antes de hacer el robot de verdad.

- **Trabajo √Ågil**: Si queremos hacerlo r√°pido y somos un equipo peque√±o, podemos decidir juntos qu√© hacer y cambiar las cosas si es necesario.

Entonces, para elegir c√≥mo construir el robot (el ciclo de vida), debemos pensar en si sabemos bien c√≥mo queremos que sea, si es importante, si necesitamos verlo r√°pido, si somos un equipo grande o peque√±o, y si podemos cambiar de idea mientras lo construimos.



---

> üìÅ Guarda este archivo en tu vault de Obsidian y completalo a medida que estudi√°s.  
> Tambi√©n pod√©s usar etiquetas como `#unidad1`, `#auto-evaluaci√≥n`, `#software` para facilitar la b√∫squeda.

