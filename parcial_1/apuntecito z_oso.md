
# 🛠️ Ingeniería de Software 2025  
## ✅ Preguntas de Autoevaluación – Unidad 1  
> Recordar el principio **KISS**: *Keep It Simple, Stupid*  
> *(mantener las soluciones lo más simples posible)*

---

### 📌 [ ] 1. Definición de Ingeniería del Software  
> **Instrucción:** Utilice menos de 100 palabras.

## 🧠 Ingeniería de Software: Definición y Principios

Según el material proporcionado, la **Ingeniería de Software** es el uso de principios fundamentales de la ingeniería con el objetivo de desarrollar software de forma **económica, confiable y eficiente** en máquinas reales.  
Esta disciplina aplica un enfoque **sistemático, disciplinado y cuantificable** al desarrollo, operación y mantenimiento del software, siendo la aplicación de la ingeniería al software.  
También se define como la rama de las ciencias de la computación que estudia la **creación de software confiable y de calidad**, basándose en métodos y técnicas de ingeniería.  

> En esencia, busca desarrollar software de manera **eficiente y con calidad** [6].

### 🏗️ Ingeniería de Software: Planificación y Calidad en el Desarrollo

Imaginen que construir una aplicación o un programa es como **construir una casa**.  
La Ingeniería de Software sería como **tener un plan detallado y organizado antes de empezar a poner ladrillos** [1, 2].  
En lugar de solo empezar a codificar sin pensar mucho, la ingeniería de software se trata de aplicar ideas y métodos de la ingeniería para hacer que ese programa sea **confiable, que funcione bien y que no cueste un ojo de la cara** [3-7].

Es como tener **reglas claras sobre cómo se debe hacer el trabajo**, desde entender qué necesita el cliente hasta probar que todo funcione correctamente [2, 8].  
Así nos aseguramos de que el software final sea de **buena calidad y sirva para lo que se creó** [7, 9, 10].  

> En resumen, es la **manera inteligente y organizada** de construir software [9, 10].



---

### 📌 [ ] 2. ¿Qué fue la crisis del software?  
> **Instrucción:** Utilice menos de 100 palabras.
## ⚠️ Pregunta 2 – La Crisis del Software

La **crisis del software**, que surgió principalmente a finales de los años 60, fue un periodo donde se hizo evidente la dificultad de la industria para desarrollar software que cumpliera con las expectativas y necesidades.  
Los proyectos de software frecuentemente **se entregaban tarde, excedían el presupuesto y no funcionaban de manera fiable**.  
Esto se debía a problemas en la **definición y comprensión de los requisitos**, **mala planificación y estimación de costos**, y prácticas de desarrollo ineficaces como el enfoque de *"codificar y corregir"*, que llevaba a **código difícil de mantener**.  

La *creciente demanda de software más complejo* superaba la *capacidad de las técnicas existentes*.

### 🧒 Explicación para un niño de 5 años

Imagina que queremos construir un juguete nuevo, como un robot.  
La **crisis del software** fue como cuando los constructores de juguetes **no sabían bien cómo hacer los robots** y **siempre se tardaban mucho en terminarlos**.  
A veces, **gastaban muchos materiales (como dinero)** y al final, ¡el robot no hacía lo que se suponía que debía hacer o se rompía muy fácil!  
Era como si empezaran a pegar piezas sin pensar mucho primero, y luego **todo quedaba desordenado** y era muy difícil arreglarlo si algo fallaba.

---

### 📌 [ ] 3. Frase incompleta según Pressman  
> Según Pressman, para gestionar un proyecto hay que **______. las ______**. _____

## 📊 Pregunta 3 – Las 4 P de la Gestión de Proyectos

Sí, según el material proporcionado, para hacer una buena gestión de proyectos, hay que tener en cuenta y gestionar las **4 P**:  
👉 **Personas**, **Proceso**, **Producto** y **Proyecto** [1-3].  
La fuente *"[Extra] Apunte - Primer Parcial.pdf"* [4] también menciona que el principal inconveniente en la gestión de proyectos es el **control simultáneo de las 4 P** (Personal, Producto, Proceso y Proyecto).

Las fuentes detallan la importancia de cada una de las 4 P en la gestión de proyectos:

### 👥 Personas  
Son consideradas lo más difícil de controlar [1, 2].  
Se enfatiza la importancia de **buscar miembros adecuados, retenerlos y motivarlos** [5].

### 🔁 Proceso  
La elección del proceso **condiciona la manera de gestionar el proyecto y construir el producto** [1, 6].  
Es importante **definir el conjunto de tareas y actividades** a llevar a cabo [6].

### 📦 Producto  
Lo primero es **determinar el ámbito**, definiendo claramente qué se quiere lograr con el producto [1, 6].  
Es esencial que el producto **entregue valor** [6, 7].

### 📈 Proyecto  
En un proyecto es obligatorio **controlar variables como Costo, Tiempo, Calidad y Alcance**, recomendándose tener mayor cuidado con el **alcance** [1, 7].


Por lo tanto, la afirmación de que hay que controlar las **4 P (Personas, Proceso, Producto y Proyecto)** para gestionar un proyecto está respaldada por el material proporcionado [1-4].

### 👶 Explicación para un niño de 5 años

Imagina que estás jugando a construir algo con bloques. Para que tu construcción quede bien, necesitas pensar en **cuatro cosas**, como si fueran cuatro amigos que te ayudan:

- 🧑‍🤝‍🧑 **Amigo Persona**: Son los niños que van a construir. Tienes que ver si todos están contentos y saben qué hacer para que trabajen bien juntos.  
- 🔧 **Amigo Proceso**: Son los pasos que van a seguir para construir. Primero poner la base, luego las paredes, luego el techo. Si siguen los pasos en orden, es más fácil que no se equivoquen.  
- 🏰 **Amigo Producto**: Es lo que quieren construir al final, ¡el castillo, la nave espacial! Tienen que saber bien qué quieren hacer para no construir otra cosa sin querer.  
- 🗓️ **Amigo Proyecto**: Es todo el plan para construir. Cuántos bloques tienen, cuánto tiempo tienen para terminar, si el castillo tiene que ser muy alto o más bajito.

Para que tu construcción salga bien, tienes que estar atento y cuidar a estos cuatro amigos.  
Si un amigo no está bien, ¡el castillo se puede caer!  
Por eso, los ingenieros de software también tienen que cuidar y estar atentos a estas **cuatro cosas** cuando hacen programas para la computadora.


---

### 📌 [ ] 4. ¿Qué es un proceso?  
> **Instrucción:** Utilice menos de 50 palabras.

## 🔄 Pregunta 4 – Definición de Proceso en Ingeniería de Software

Según el material proporcionado, un **proceso** en Ingeniería de Software es un:

> 🔧 **Conjunto de actividades, acciones y tareas que se ejecutan para crear un producto** [1, 2].

Este proceso **define una estructura** para lograr la obtención eficaz de tecnología dentro del desarrollo de software [1, 2].  
Además, también se describe como:

> 🛠️ **Un conjunto de actividades para desarrollar o mantener software y sus productos asociados** [3, 4].

En resumen, el proceso es **la manera organizada en la que trabajamos** para lograr que el software funcione correctamente, cumpla con los objetivos y se pueda mantener en el tiempo.

### 👶 Explicación para un niño de 5 años

Imagina que querés hacer una torta 🎂.  
Para que salga rica, no podés simplemente mezclar todo al azar.  
Tenés que seguir **una receta**, paso a paso:  
primero mezclar los ingredientes, después poner la mezcla en el molde, prender el horno, y así.

El **proceso en software** es como esa receta, pero en vez de hacer una torta, **hacemos programas para la compu**.  
Los programadores siguen **una serie de pasos ordenados** para que todo funcione bien y no se olviden de nada importante.

Si no seguís la receta, la torta puede salir mal...  
¡y con el software pasa lo mismo!


---

### 📌 [ ] 5. Diferencias entre procesos predictivos y empíricos  
> ¿En cuál se enmarca la agilidad?

## 🔁 Pregunta 5 – Control Predictivo vs. Control Empírico

### 🧠 Definición técnica

Según el material proporcionado:

- En los **procesos de control predictivo**, las variables del proyecto se **identifican claramente, se controlan y su comportamiento se puede predecir** [1, 2].
  - Se inspiran en las líneas de producción.
  - Se basa en que **siempre que sigas el mismo proceso, vas a obtener el mismo resultado** [1, 2, 3].
  - Ejemplo clásico: el **modelo en cascada** [1].

- En cambio, los **procesos de control empíricos** aceptan que **no todo se puede predecir ni controlar**, sobre todo por la **complejidad del software** [2, 4, 5].
  - Se mide constantemente lo que se va construyendo.
  - Se adapta el trabajo según lo que se ve y se necesita.
  - Ejemplo clásico: **metodologías ágiles** como Scrum [4, 6].

### 🏠 Ejemplo práctico: Construir una casa para un perro

#### 🛠️ Proceso Predictivo
1. Dibujás un plano muy detallado desde el principio: medidas, materiales, cómo poner cada clavo [1, 3].
2. Construís siguiendo el plan **sin cambios**.
3. Al final mostrás la casa terminada al dueño [7].
4. Si no le gusta, **cambiar algo cuesta mucho trabajo** [8].

#### 🔄 Proceso Empírico
1. Tenés una idea general (una casita con puerta) [2].
2. Hacés la base y una pared, y **mostrás al dueño** cómo va quedando.
3. Si el dueño quiere cambiar algo (como mover la puerta), **adaptás el plan** [2, 9].
4. Repetís el ciclo hasta terminar la casa que **seguro le gusta al perro** [9].

### 👶 Explicación para un niño de 5 años

#### ☀️ Dibujar un sol

- **Control Predictivo**:  
  Dibujás un sol perfecto de una vez: primero el círculo, luego todos los rayitos iguales.  
  Pero si querías ponerle una carita y te olvidaste… ¡es difícil de agregar al final!

- **Control Empírico**:  
  Dibujás un círculo y le preguntás a tu mamá si parece un sol.  
  Ella dice: “¡Sí, pero le faltan rayitos!”. Dibujás los rayitos.  
  Luego ella dice: “¡Qué lindo! ¿Y si le ponés una carita feliz?”.  
  ¡Entonces la dibujás! Así lo hacés paso a paso, cambiando según lo que te dicen 😊.



---

### 📌 [ ] 7. Beneficio de un ciclo de vida ágil vs. en cascada  
> Incluya también riesgos y costes.
## 🔁 Pregunta 7 – Agilidad vs. Cascada: Beneficios, Riesgos y Costos

### 🚀 Beneficios de un ciclo de vida ágil vs. uno en cascada

Según "[Extra] Apunte - Primer Parcial.pdf" y otros documentos [1–4]:

- **📦 Entregas rápidas y funcionales**: Se entrega software que funciona cada pocas semanas, generando valor temprano [1, 5].
- **👂 Validación temprana con el cliente**: Se verifica rápidamente si el producto satisface al usuario final, reduciendo el riesgo de construir "lo equivocado" [1, 2].
- **📄 Menos documentación innecesaria**: Se prioriza el software funcionando sobre la burocracia documental [1, 5].
- **⏳ Mejor estimación del tiempo restante**: Cada iteración permite ajustar con más precisión la estimación del tiempo total del proyecto [1, 6, 7].
- **🤝 Mejor interacción en el equipo**: Favorece la colaboración y comunicación constante [1, 8].
- **🔁 Buena respuesta al cambio**: Se aceptan y se adaptan los cambios, incluso en etapas avanzadas del desarrollo [1, 5, 9].
- **❌ Menor riesgo de cancelación**: El cliente ve valor de manera continua y no pierde el interés [2].
- **💰 Menor costo de los cambios**: Especialmente si se detectan temprano; la agilidad busca **mantener los costos de cambio bajos** a lo largo del tiempo [2, 10–13].

### ⚠️ Riesgos

- **Agilidad reduce riesgos** como:
  - Construir algo que el cliente no necesita [2].
  - Que el cliente pierda el interés por falta de avances visibles [2].

- En proyectos grandes, **la agilidad mal gestionada puede aumentar los costos** si se hacen muchos cambios sin control [14].

### 💸 Costos

- **Menores costos de cambio** en comparación con cascada [2].
- **Evita documentación innecesaria**, reduciendo también tiempo y esfuerzo [1].
- En cascada, los cambios **tardíos son muy costosos**. En ágil, se busca **invertir la curva de costos de cambio** [15].


### 🏰 Explicación para un niño de 5 años: ¡Construyamos un castillo de arena!

#### 🌊 En cascada:
1. Dibujás todo el castillo con torres y puertas antes de empezar [16].
2. Lo hacés todo sin mostrar nada hasta el final.
3. Cuando terminás, tu amigo lo ve y dice:  
   **"¡No me gusta la puerta!"**  
   Pero ahora cambiarla **cuesta mucho trabajo** o hay que **romperlo** 😓 [1, 15, 16].

#### 🧱 Con agilidad:
1. Hacés una torre chiquita y se la mostrás a tu amigo.
2. Él dice: **"¡Qué bien!"**
3. Hacés una muralla, y tu amigo dice: **"Poné la puerta acá"**, y vos **la cambiás fácil** 🧠.
4. Construís paso a paso y siempre le preguntás si le gusta.
5. Si hay que cambiar algo, **no es grave** y todos están contentos 😊.

Así, tu amigo no se aburre y el castillo sale como él lo quiere ❤️.


---

### 📌 [ ] 8. Gestión de Proyectos de Software  
> ¿Qué entiende por gestión de proyectos?  
> Mencione los pilares para que sea eficaz.

## 🏗️ Pregunta 8 – Gestión de Proyectos de Software: Las 4 Ps

### 📋 ¿Qué es la Gestión de Proyectos de Software?

Es el conjunto de actividades para **planificar, supervisar y controlar**:
- Al personal,
- Los procesos,
- Los eventos,
- Y el producto en sí,

durante **todo el ciclo de vida del software**, desde la idea inicial hasta su implementación operativa [1–3].

También incluye el **mantenimiento**, que puede convertirse en un nuevo proyecto en sí mismo [2, 3].

---

### 🔑 Las 4 Ps de la Gestión de Proyectos

Una gestión eficaz se basa en **cuatro pilares fundamentales**:

#### 👥 1. Personal
- El equipo humano es clave.
- Hay que saber **atraer, formar, motivar, organizar y retener** al personal necesario para cumplir los objetivos [4, 6].

#### 🧱 2. Producto
- Se definen los **objetivos y el alcance** del producto.
- Se consideran **alternativas de solución** y se identifican **restricciones técnicas y administrativas** [6–8].

#### 🧭 3. Proceso
- El proceso actúa como **marco conceptual** para crear el plan de desarrollo [6, 7, 9].
- Debe ser **elegido por el equipo**, ya que define cómo se gestionará y construirá el producto [7, 9].

#### 📆 4. Proyecto
- Es la **planificación y el control** de todo el trabajo necesario.
- Implica organizar tiempos, recursos, tareas y objetivos con un propósito específico [10].

---

### ⚠️ Dificultades
El mayor desafío es **coordinar simultáneamente** las 4 Ps:
- No siempre se sabe con certeza **qué hay que hacer** ni **quién debe hacerlo** desde el inicio del proyecto [10].

---

### 🧸 Explicación para un niño de 5 años: ¡Construyamos un castillo de bloques!

Gestionar el proyecto es como ser el **jefe constructor** del castillo:

#### Las 4 Ps son como ingredientes secretos para que todo salga bien:

- **👫 Personas (Amigos):** Necesitás amigos que te ayuden a poner los bloques y que se diviertan haciéndolo.
- **🏰 Producto (Castillo):** Decidís qué castillo querés. ¿Va a tener torres? ¿Puente levadizo?
- **🔨 Proceso (Cómo construir):** Pensás cómo lo van a hacer. ¿Primero la base? ¿Cada uno hace una parte?
- **🗓️ Proyecto (Toda la construcción):** Te asegurás de que nadie se olvide qué hacer, que haya suficientes bloques, y que terminen a tiempo.

Ser el jefe no es fácil, porque tenés que pensar en **todo al mismo tiempo**. Pero si lo hacés bien, ¡el castillo queda increíble! 😄



---

### 📌 [ ] 9. Organigramas y equipos ágiles  
> ¿Cuál organigrama se parece más a un equipo ágil?  
> Justifique en menos de 100 palabras.

## 🤝 Pregunta 9 – Equipos Ágiles: Liderazgo Guía y Decisión Colectiva

### 🌀 ¿Cómo funciona el liderazgo en los equipos ágiles?

En los equipos ágiles, el **liderazgo no se basa en la autoridad**, sino en la **guía y acompañamiento**.

- El líder **no toma las decisiones por el equipo** [1, 2].
- Su función principal es **facilitar, motivar y ayudar al equipo** a alcanzar su mejor rendimiento.

---

### 👥 ¿Cómo son los equipos ágiles?

Los equipos ágiles tienen las siguientes características clave:

- Son **pequeños**, **autoorganizados** y **multifuncionales** [3–8].
- **Las decisiones se toman en grupo**, a través del **consenso**.
- Hay **interacción constante** entre todos los miembros.

Este enfoque se corresponde con:

- El **paradigma aleatorio y abierto** [9, 10].
- El **organigrama Descentralizado Democrático (DD)** [11], donde:
  - No hay un jefe permanente,
  - La comunicación es horizontal,
  - Las decisiones son consensuadas entre todos.

### 🧸 Explicación para un niño de 5 años: ¡Jugamos a construir con Legos!

Imaginá que estás con tus amigos construyendo con Legos. En vez de que uno solo diga qué hacer, **todos se sientan y deciden juntos** qué van a construir [4, 6].

Hay un amigo que **no manda**, sino que **ayuda a que todos se pongan de acuerdo** y trabajen bien juntos [1, 2].

Cada amigo tiene una habilidad especial, como una **banda de superhéroes** donde todos hacen algo importante [7, 12].

Así, construyen algo genial y se divierten trabajando como un verdadero **equipo**. 💪

---

### 📌 [ ] 10. Caso histórico: solución de una década a otra  
> Mencione un caso en la historia de la ingeniería de software.


## 🛠️ Pregunta 10 – Evolución de la Ingeniería de Software: 1970s a 1980s

### 🕰️ ¿Qué pasó en la ingeniería de software entre los 70s y los 80s?

#### **Los años 70: Formalidad y procesos en cascada**

En los años 70, la ingeniería de software seguía un modelo muy **formal y estructurado** que estaba inspirado en la **ingeniería de hardware** [1–3]. Se introdujeron conceptos clave como:

- **Ingeniería de requisitos**: Definir qué debe hacer el software antes de empezar a programar.
- **Diseño como etapa previa a la programación**: Antes de escribir código, se diseñaba el sistema [1–6].
- **Programación estructurada**: Ideas de cohesión y acoplamiento para mejorar la organización del código [1–6].

Sin embargo, este enfoque generó varios problemas:

- Los **métodos formales** eran difíciles de usar por muchos programadores.
- El **modelo en cascada** era lento, costoso y requería mucha **documentación** [3, 7, 8].
- Las **organizaciones excedieron los costos** de hardware, y se comenzó a preocupar por mejorar la **productividad del software** [7, 8].

#### **Los años 80: Soluciones y avances**

En los años 80, comenzaron a surgir **iniciativas para mejorar la productividad y escalabilidad** en la ingeniería de software [3, 8, 9]. Algunos de los avances fueron:

- Se buscó **evitar la etapa de pruebas** para reducir costos, y se progresó en **herramientas de testing** y **gestión de configuración** [3, 10].
- **Programación Orientada a Objetos (POO)**: Un nuevo enfoque que permitió organizar el código de manera más eficiente.
- Se introdujeron **herramientas CASE** para automatizar partes del proceso de desarrollo [3, 10–13].
- Se **mejoró la reutilización de software**, lo que ayudó a reducir trabajo repetitivo y racionalizó el desarrollo [3, 9, 11, 13–15].
- Aparecieron modelos para **estandarizar los procesos**, como el **modelo de madurez de la capacidad de software (CMM)** [3, 16–18].

---

### 🧸 Explicación para un niño de 5 años: ¡Construyendo Juguetes!

Imagina que en los años 70, construir un juguete era como seguir un **libro de instrucciones muy largo y complicado** con dibujos pequeños y muchas reglas [1, 19, 20]. A veces, las reglas eran tan difíciles que **nadie entendía cómo seguir** construyendo, y **tardaban mucho** en terminar el juguete [7, 8].

En los años 80, la gente pensó que sería mejor tener **instrucciones más fáciles** y usar **piezas que ya tenían hechas** de otros juguetes para **construir más rápido** [9, 11, 14]. También inventaron **cajas de herramientas** especiales para **guardar y encontrar las piezas más fácilmente** [10]. 

Así, **construir juguetes** se volvió **más rápido y menos complicado**. 🧸⚡


---

### 📌 [ ] 11. Rol de manager: formación de equipo ágil  
> ¿Qué aspectos y factores debería tener en cuenta?

## 🛠️ Pregunta 11 – Formando Equipos Ágiles: Guía Concisa

### 🤝 ¿Qué tener en cuenta al formar un equipo de software ágil?

#### **Aspectos clave para formar un equipo ágil:**

1. **Tamaño del equipo**: El equipo debe ser pequeño, idealmente entre **3 y 7 personas**, para facilitar la comunicación y la toma de decisiones. Un equipo pequeño ayuda a llegar a un consenso más fácilmente [1–4].

2. **Multifuncionalidad**: Es esencial que el equipo sea **multifuncional**, es decir, que cada miembro tenga habilidades variadas para realizar el trabajo sin depender de otros equipos. Esto implica tener expertos en cada área y otros dispuestos a aprender [1, 4–8].

3. **Autoorganización**: El equipo debe ser **autoorganizado**, con la capacidad de tomar decisiones por consenso y ser responsable de ellas. Mi rol como manager sería más de **guía** que de tomar decisiones por el equipo [2, 5, 7, 9–14].

4. **Motivación y retención del personal**: Buscar a los miembros más adecuados, motivarlos y mantenerlos, creando un entorno de trabajo productivo [1, 3, 17, 18].

5. **Madurez técnica**: El equipo debe ser **técnicamente maduro**, entendiendo el impacto de la no calidad [1, 3, 12, 19, 20].

6. **Comunicación y colaboración**: Fomentar una constante **interacción y comunicación** entre los miembros, con decisiones tomadas en consenso. La **comunicación cara a cara** es muy eficaz [4, 5, 8, 10, 15, 21].

7. **Inclusión de roles necesarios**: Asegurarme de que el equipo incluya todos los **roles necesarios** (como testers), integrados dentro del propio equipo [6, 23].

8. **Alineación con los valores ágiles**: Buscar personas cuyas **valores no negociables** coincidan con los del equipo y con los principios ágiles [24–26].

9. **Estabilidad del equipo**: Intentar mantener al equipo junto el mayor tiempo posible para mejorar la **estimación** y el **rendimiento** [27].


### 🧸 Explicación para un niño de 5 años: ¡Construyendo con Legos!

Imagina que vamos a formar un equipo de **constructores de Legos** muy rápido y divertido:

- **Pocos amigos**: Necesitamos pocos amigos en el equipo, como tú y algunos más, ¡no muchísimos! Así podemos hablar mejor y decidir rápido qué construir [1, 2].
- **Amigos que saben muchas cosas**: Cada amigo debe ser bueno en algo diferente con los Legos, como uno sabe hacer torres, otro sabe hacer puentes, y otro tejados. Así no necesitamos llamar a otros niños para que nos ayuden [1, 5].
- **Todos deciden**: Todos los amigos juntos van a decidir qué vamos a construir y cómo lo vamos a hacer. Yo, como el mayor, solo les ayudaré a que se pongan de acuerdo y a que tengan todos los Legos que necesiten [5, 9].
- **Amigos contentos**: Quiero que mis amigos estén contentos y con ganas de construir [1].
- **Amigos que construyen bien**: Mis amigos deben saber cómo encajar bien las piezas para que el castillo no se caiga [1].
- **Hablar mucho**: Tenemos que hablar mucho entre nosotros para saber qué está haciendo cada uno y si necesitamos ayuda [15].
- **Todos ayudan en todo**: Si necesitamos probar si la puerta se abre bien, todos podemos intentarlo, no solo un amigo especial [23].
- **Amigos que les gusta trabajar así**: Quiero amigos a los que les guste construir rápido y cambiar las cosas si no quedan bien [24, 25].
- **El mismo equipo siempre**: Si siempre construimos con los mismos amigos, ¡cada vez lo haremos mejor y más rápido! [27].



---

### 📌 [ ] 12. Ingeniería de Software en los años 50  
> ¿Cuál fue su principal característica?

## 🛠️ Pregunta 12 – Ingeniería de Software: Paralelismos con el Hardware en los Años 50

### 🖥️ ¿Cómo se veía la ingeniería de software en los años 50?

En la década de 1950, la **Ingeniería de Software** estaba muy influenciada por la ingeniería de **hardware**. Los ingenieros pensaban que el software se podía desarrollar de la misma forma que el hardware, utilizando los mismos principios y enfoques [1–4]. Esto se debía a que el costo del **hardware** era mucho mayor que el del software, y los ingenieros de software también trabajaban a menudo en el desarrollo de hardware [3]. 

Se creía que el software debía ser muy **preciso** y **detallado**, con especificaciones largas y complejas. La filosofía era similar a la de "medir dos veces, cortar una" [4], lo que implicaba que había que planificar cada parte del software con mucho cuidado antes de implementarla.


### 🧸 Explicación para un niño de 5 años: ¡Construyendo un coche de juguete!

Imagina que queremos construir un **coche de juguete**. En los años 50, la gente pensaba que hacer programas para las computadoras era igual que **construir partes del coche**, como las ruedas o el motor [6]. Creían que había que planificarlo todo muy bien, como si fueran piezas de **metal** [4]. Era como si pensaran que hacer un programa era como **armar un rompecabezas** muy grande y complicado, pieza por pieza, igualito a cómo se construye un objeto de verdad [3].


---

### 📌 [ ] 13. Inconvenientes en los años 60 o 70  
> Explique mediante un ejemplo.

## 🛠️ Pregunta 13 – Ingeniería de Software en los Años 60: Codificar y Corregir

### 🖥️ ¿Cómo era la ingeniería de software en los años 60?

En los años 60, la ingeniería de software comenzó a mostrar sus inconvenientes con el enfoque llamado "codificar y corregir" [1, 2]. Aunque ya existían avances tecnológicos, quedó claro que el software no podía tratarse como el hardware. En lugar de realizar una planificación exhaustiva antes de comenzar, se prefería **comenzar a programar** y luego corregir los errores a medida que surgían [1, 3].

Este enfoque dio lugar a lo que se conoce como "**código espagueti**", un código desordenado y difícil de entender, incluso para la persona que lo había escrito [4]. Esto hacía que **encontrar errores** fuera muy complicado y consumiera mucho tiempo [2]. Además, mantener y actualizar este software se volvió muy complicado, ya que cualquier cambio podía generar nuevos problemas en otras partes del código [5]. Durante este tiempo, el desarrollo de software dependía a menudo de programadores que trabajaban muchas horas extra para solucionar problemas de último minuto [2, 4].


### 🧸 Explicación para un niño de 5 años: ¡Construyendo una torre de bloques!

Imagina que quieres construir una **torre de bloques** muy alta, pero en lugar de pensar bien cómo hacerlo primero, solo comienzas a poner bloques uno encima del otro sin un plan [2]. Al principio puede que la torre suba, pero si pones los bloques sin cuidado, ¡la torre se tambaleará y será difícil poner más bloques encima [4]!

Si quieres cambiar algo abajo, ¡todo lo de arriba puede caerse! [5].

En los años 60, a veces **construían programas de computadora** así, sin mucho pensar primero [2]. El código era como una torre de bloques desordenada y si había un error, era muy difícil encontrarlo y arreglarlo sin que se rompiera otra parte [4]. Solo una persona muy lista que conocía todos los bloques enredados podía arreglarlo si se caía [2, 4].



---

### 📌 [ ] 14. Inconvenientes de la gestión clásica  
> Explique con sus palabras.

## ⚠️ Pregunta 14 – Desventajas de la Gestión Clásica en Software

### 🖥️ ¿Cuáles son las desventajas de la gestión clásica en la ingeniería de software?

Los modelos clásicos de gestión de proyectos en ingeniería de software presentan varias desventajas clave:

1. **Rigidez y dificultad para adaptarse a los cambios**: Modelos como el de cascada siguen un flujo secuencial donde una etapa debe completarse antes de pasar a la siguiente [1-6]. Esto dificulta la incorporación de cambios en los requerimientos una vez que el proyecto avanza, generando confusión y retrasos [3, 6].

2. **Entrega tardía del producto funcional**: En modelos clásicos como el cascada, no se dispone de una versión funcional del software hasta las etapas finales [3, 6, 7], lo que impide obtener retroalimentación temprana y detectar errores importantes a tiempo [3, 7, 8].

3. **Suposición de requisitos estables y bien definidos**: Los modelos clásicos asumen que los requisitos del cliente son claros desde el inicio, pero en la práctica estos pueden evolucionar durante el desarrollo [3, 6, 9].

4. **Estados de bloqueo y baja interacción**: Al ser secuencial, los miembros del equipo a menudo deben esperar a que otros terminen su parte del trabajo, lo que disminuye la productividad [7, 10]. Además, los equipos son grandes y suelen tener poca interacción [2, 11-13].

5. **Enfoque intenso en la documentación**: Los modelos clásicos requieren mucha documentación en cada etapa [2, 14-16], lo que puede resultar lento y costoso [14, 15].

6. **Dificultad en la estimación**: Estimar los costos y tiempos de un proyecto desde el principio es un reto importante [17-21].

7. **Control simultáneo de las 4 P**: Los modelos clásicos intentan controlar simultáneamente las Personas, el Proceso, el Producto y el Proyecto, lo cual a menudo es muy difícil de lograr [12, 22-34].

### 🧸 Explicación para un niño de 5 años: ¡Construyendo un castillo de arena!

Imagina que quieres construir un **castillo de arena muy grande** siguiendo un dibujo muy detallado que hiciste al principio [1, 2].

1. **Reglas estrictas**: Si quieres cambiar algo de tu castillo, como hacerlo más alto o moverlo a otro lugar, ¡es muy difícil! [3, 6] Tienes que seguir el dibujo original aunque ya no te guste tanto.

2. **Castillo al final**: No verás cómo va quedando el castillo hasta que esté casi listo [3, 6, 7]. Si no queda bien o algo está mal hecho, tendrás que deshacer mucho trabajo.

3. **Todos esperan**: A veces, los amigos tienen que esperar a que los demás terminen de hacer su parte, como las torres o las banderas [7, 10]. ¡Eso hace que tarde más en terminarse!

4. **Muchos papeles**: Tienes que dibujar muchos planos y escribir muchas cosas antes de empezar a construir [2, 14, 16]. ¡A veces sería más divertido simplemente empezar a construir!

5. **Adivinar cuánto tiempo nos llevará**: Al principio, tienes que adivinar cuánto tiempo tardarás en hacer todo el castillo, pero puede ser difícil porque es muy grande y complicado [17, 19, 21].

Es como si tuviéramos un plan muy fijo y no pudiéramos cambiarlo mucho, y solo veríamos el resultado final mucho después. A veces, es mejor construir poco a poco y ver si nos gusta para poder cambiar las cosas si es necesario.



---

### 📌 [ ] 15. Modelo de proceso empírico con un antipatrón  
> Ejemplo que ilustre una característica del modelo empírico usando un antipatrón.

## ⚠️ Pregunta 15 – Antipatrones, Cohesión, Acoplamiento y Procesos Empíricos

### 🖥️ ¿Qué son los antipatrónes, la cohesión, el acoplamiento y cómo se relacionan con los procesos empíricos?

- **Antipatrón**: Es una solución común a un problema recurrente que parece efectiva al principio, pero que con el tiempo genera más problemas y dificultades [1].
- **Modelo de proceso empírico**: En este enfoque de desarrollo de software, se da importancia a la **experiencia**, la **experimentación** y la **adaptación continua**. Acepta que los requisitos pueden cambiar y que no todo se puede predecir desde el principio [2]. Los ciclos cortos de trabajo, la entrega frecuente de software y la retroalimentación constante son clave para adaptarse al cambio [2].
  
Un **modelo empírico** se enfoca en la capacidad de **adaptación al cambio** [2]. 

- **Cohesión** *(Relaciones entre modulos)*: Se refiere a la *relación entre las diferentes partes de un módulo de software*. **Baja cohesión** ocurre cuando las partes de un módulo no están claramente relacionadas entre sí [5]. Es como tener cosas que no tienen nada que ver dentro de una misma caja.
- **Acoplamiento** *(Dependencia entre modulos)*: Se refiere a cómo las partes de un software dependen unas de otras. **Alto acoplamiento** ocurre cuando las partes están muy interconectadas y dependen mucho unas de otras, lo que hace que cambiar una parte pueda romper otras [4, 5]. Es como tener bloques de Lego pegados con mucha cola; al intentar mover uno, toda la torre se cae.

En un **modelo empírico**, **baja cohesión** y **alto acoplamiento** son antipatrónes, ya que dificultan la adaptación al cambio. Si el sistema es complicado de modificar debido a la interdependencia entre partes, el equipo pierde tiempo tratando de entender los impactos de los cambios y corrigiendo problemas, en lugar de avanzar con nuevas funcionalidades [5, 6, 7].

---

### 🧸 Explicación para un niño de 5 años: ¡Construyendo un castillo de arena!

Imagina que estamos construyendo un **castillo de arena con muchos cuartos**.

- **Antipatrón**: Es como si cada cuarto tuviera **muchísimas cosas diferentes** que no tienen nada que ver entre sí (baja cohesión). Y además, todos los cuartos estuvieran conectados por **muchísimos túneles secretos**. Si tocas una cosa en un cuarto, ¡todo se rompe en otro cuarto lejano! (alto acoplamiento).

- **Proceso Empírico**: Queremos construir el castillo poquito a poquito. Mostramos a nuestro amigo lo que hemos hecho y, si quiere que cambiemos algo, como añadir una torre o mover una muralla, ¡queremos que sea fácil hacerlo!

- **El problema del antipatrón**: Pero si nuestro castillo tiene los cuartos llenos de cosas sin sentido y todos los túneles secretos, cuando nuestro amigo nos pida una torre más grande, ¡será muy difícil cambiarla sin que se caigan otras partes del castillo! Tendremos que tener mucho cuidado, tomará mucho tiempo y, ¡quizás rompamos algo más sin querer! 

Es mejor que cada cuarto tenga cosas que **sí tengan que ver entre sí** y que no estén todos **tan pegados** para poder cambiar el castillo fácilmente.


---

### 📌 [ ] 16. Selección del ciclo de vida adecuado  
> Principales factores y características a tener en cuenta.

## ⚙️ Pregunta 16 – Selección del Ciclo de Vida de Desarrollo de Proyectos

### 🖥️ ¿Cómo se selecciona el ciclo de vida adecuado para el desarrollo de un proyecto?

La selección del ciclo de vida adecuado depende de diversos factores relacionados con las características y necesidades del proyecto. A continuación se presentan los principales aspectos a considerar:

- **Comprensión y estabilidad de los requerimientos**: Si los requerimientos son estables y bien comprendidos desde el inicio, un modelo secuencial como el modelo en cascada podría ser adecuado [1-4]. Sin embargo, si los requerimientos cambian con frecuencia, se deben considerar modelos evolutivos, de prototipado o ágiles [6-10].
  
- **Riesgo del proyecto**: Para proyectos con alto riesgo, el **modelo en espiral** es útil para reducir los riesgos de manera incremental, utilizando prototipos [12, 13]. Los enfoques tradicionales realizan un análisis de riesgos al inicio, mientras que los métodos ágiles lo hacen de manera iterativa [17-19].

- **Necesidad de entrega temprana de funcionalidades**: Los modelos **incrementales** o **evolutivos** permiten entregar versiones tempranas del software, y los métodos ágiles se centran en entregar rápidamente funcionalidades [6, 8, 20-23].

- **Tamaño y complejidad del proyecto**: Los métodos ágiles son más adecuados para proyectos pequeños [11], mientras que proyectos grandes pueden beneficiarse de un enfoque **incremental o en espiral** [12, 13, 20].

- **Estabilidad del entorno del proyecto**: En entornos inestables o con cambios rápidos en los requisitos, los métodos ágiles son más apropiados. Para entornos más estables, los métodos secuenciales son más aplicables [2, 4, 10].

- **Costo de modificación del producto**: Si modificar el producto es costoso, los enfoques ágiles pueden no ser apropiados. La curva de Boehm muestra que los costos de cambio son más bajos durante las fases de análisis y diseño [25-28].

- **Cultura organizacional y del equipo**: Si la organización favorece la interacción entre las personas sobre los procesos, los métodos ágiles pueden ser más efectivos, ya que promueven equipos pequeños y autoorganizados [29-32].

- **Cumplimiento con estándares y normas de calidad**: Si es necesario cumplir con normativas estrictas, un enfoque predictivo puede ser más adecuado. Sin embargo, los métodos ágiles también enfocan la calidad de manera constante [10, 24, 33].

- **Valor del usuario y retorno de la inversión (ROI)**: Los métodos ágiles priorizan la entrega de funcionalidades que aporten mayor valor al cliente [34-37].

- **Criticidad y confiabilidad del software**: Para proyectos críticos, es necesario un enfoque que enfatice la prevención y eliminación temprana de errores [38-40].


### 🧸 Explicación para un niño de 5 años: ¡Construyendo un robot!

Imagina que queremos construir un **robot nuevo**. ¿Cómo decidimos la mejor forma de hacerlo?

- **Modelo Cascada**: Si sabemos exactamente cómo queremos que sea el robot y no vamos a cambiar de idea, seguimos un dibujo paso a paso, haciendo una cosa tras otra.

- **Modelos Incrementales o Ágiles**: Si no estamos seguros de cómo queremos el robot, podemos construir un brazo primero, luego una pierna, y ver cómo funciona antes de seguir construyendo. Así lo hacemos poquito a poco.

- **Modelo en Espiral**: Si el robot es muy importante, como uno que explora el espacio, tenemos que tener mucho cuidado. Primero planeamos, construimos un poquito, probamos mucho, y luego repetimos este proceso.

- **Modelo de Prototipado**: Si queremos ver cómo se ve el robot rápido, podemos hacer un dibujo rápido o un modelo sencillo con plastilina, y enseñárselo a nuestro amigo antes de hacer el robot de verdad.

- **Trabajo Ágil**: Si queremos hacerlo rápido y somos un equipo pequeño, podemos decidir juntos qué hacer y cambiar las cosas si es necesario.

Entonces, para elegir cómo construir el robot (el ciclo de vida), debemos pensar en si sabemos bien cómo queremos que sea, si es importante, si necesitamos verlo rápido, si somos un equipo grande o pequeño, y si podemos cambiar de idea mientras lo construimos.



---

> 📁 Guarda este archivo en tu vault de Obsidian y completalo a medida que estudiás.  
> También podés usar etiquetas como `#unidad1`, `#auto-evaluación`, `#software` para facilitar la búsqueda.

