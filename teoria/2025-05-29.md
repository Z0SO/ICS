
# 🧪 Técnicas de Pruebas de Software

>[!NOTE]
> Basado en información de distintas fuentes, a continuación te explico las técnicas de pruebas de software de forma sencilla, clara y visual.

---

## 🧷 ¿Qué son las pruebas de software?

Las **pruebas de software** son un conjunto de actividades **planificadas y sistemáticas** con el objetivo de **encontrar errores**.

> 🎯 *Una buena prueba es aquella que tiene una alta probabilidad de encontrar un error.*

---

## 🧰 Clasificación de las Técnicas

Existen **dos categorías principales** de técnicas para diseñar casos de prueba:

- 🔍 **Caja Blanca**
- 🎭 **Caja Negra**

Ambas técnicas nos guían sobre **cómo pensar para crear pruebas efectivas** que aseguren el buen funcionamiento del software.

---

## 🔍 Prueba de Caja Blanca (o "Caja de Cristal")

> "Miramos **dentro del código**: cómo funciona internamente."

### 🧠 ¿En qué consiste?

- Se basa en la **estructura interna del programa**.
- Analiza decisiones (`if`, `switch`), bucles (`for`, `while`), etc.
- Su objetivo es **verificar los diferentes caminos lógicos del código**.
- También permite examinar **el estado interno del programa**.

### 🛠️ Técnicas de Caja Blanca

#### 🔁 Prueba del Camino Básico
- Asegura que **cada camino posible** dentro del código se ejecute al menos una vez.
- Se utiliza el concepto de **complejidad ciclomática** para contar los caminos básicos.

#### 🧩 Pruebas de Estructura de Control
- Evalúan las diferentes estructuras de decisión y flujo del código:
  - 🔹 *Prueba de Condición*: verifica condiciones lógicas (`true/false`).
  - 🔹 *Prueba de Flujo de Datos*: sigue las **definiciones y usos de variables**.
  - 🔹 *Prueba de Bucles*: evalúa **distintos tipos de bucles** y sus comportamientos.

---

## 🎭 Prueba de Caja Negra (o "Prueba de Comportamiento")

> "Solo importa lo que el software **hace**, no cómo lo hace."

### 🔍 ¿En qué consiste?

- No se analiza el código interno.
- Se basa en los **requisitos funcionales** del software.
- Evalúa **entradas y salidas** sin mirar la implementación.
- Se realiza a través de la **interfaz del software**.

### 🛠️ Técnicas de Caja Negra

#### 📈 Pruebas Basadas en Grafos
- Usan **diagramas** para modelar interacciones entre elementos del sistema.
- Muy útil para sistemas complejos.

#### 🧪 Partición Equivalente
- Divide las entradas en **grupos equivalentes**.
- Basta con probar **una entrada por grupo**.

#### 🚧 Análisis de Valores Límite
- Prueba los valores **en los bordes del rango permitido**.
- Ejemplo: Si la entrada es de 1 a 100 → probar 0, 1, 100, 101.

#### ⚖️ Prueba de Comparación
- Se usa en sistemas donde la **confiabilidad es crítica**.
- Consiste en comparar los resultados de **múltiples versiones del software**.

#### 🧮 Prueba de la Tabla Ortogonal
- Mencionada como técnica de caja negra.
- Utilizada para **cubrir combinaciones eficientes de datos de entrada**.

---

## ✅ Resumen Final

| Técnica       | ¿Qué observa?           | ¿Cómo prueba?                   |
|--------------|--------------------------|---------------------------------|
| 🧠 **Caja Blanca** | El código interno         | Evalúa caminos, bucles y condiciones |
| 🎭 **Caja Negra**  | El comportamiento externo | Evalúa entradas y salidas       |

---

> 📌 **Conclusión:** Las técnicas de pruebas —ya sean de **caja blanca** o **caja negra**— son herramientas que te ayudan a **diseñar casos de prueba eficaces** para detectar errores y garantizar la calidad del software.

---

🧡 *Probar es cuidar. Las pruebas no son para desconfiar del software, sino para proteger su calidad y fiabilidad.* 🧡






# 🧪 Facilidad de Prueba (Testability)

---

## 🎯 ¿Qué es la Facilidad de Prueba?

La **facilidad de prueba** —también conocida como *testabilidad* o *comprobabilidad*— se refiere a:

> 🧩 **Qué tan fácil es probar un programa de software**.

Es decir, mide el **esfuerzo requerido** para verificar que un sistema o módulo realiza correctamente las funciones que se espera que realice.

> 🛠️ *Un software con alta facilidad de prueba facilita la detección y corrección de errores.*

---

## 🏗️ ¿Por qué es importante?

🔸 La facilidad de prueba **debe considerarse desde el diseño e implementación** del software.  
🔸 Ayuda a construir **software mantenible y confiable**.  
🔸 Reduce el tiempo y costo en **etapas posteriores** del ciclo de vida.

---

## 📋 Características de un Software Fácil de Probar

A continuación, las propiedades que mejoran la facilidad de prueba en un sistema:

| 🧱 Característica            | 📌 Descripción                                                                 |
|-----------------------------|---------------------------------------------------------------------------------|
| ✅ **Simplicidad**           | Menos complejidad = pruebas más rápidas y sencillas.                           |
| 🔍 **Facilidad de Comprensión** | A mayor comprensión del sistema, mejores decisiones al diseñar pruebas.       |
| 🧩 **Capacidad de Descomposición** | Permite dividir el software en **módulos independientes** para probar por separado. |
| 🎮 **Controlabilidad**       | Posibilidad de **controlar los datos y estados** durante las pruebas.          |
| 👁️ **Observabilidad**       | Capacidad de **ver resultados y comportamientos** del sistema durante la prueba.|

---

## 🧾 Resumen

> La **facilidad de prueba** es una propiedad clave de calidad que indica:

🎯 **¿Cuánto trabajo cuesta verificar que un software funciona correctamente?**

🧠 *Un software bien diseñado no solo funciona... también se deja probar.* 💡





----




# 🧪 Diseño de Casos de Prueba

> 💡 **Diseñar un caso de prueba** es preparar una situación para evaluar si el software cumple con un requisito específico.  
> Las técnicas de prueba son precisamente **estrategias para diseñar estos casos de manera eficaz**.

---

## 🎯 ¿Qué es un caso de prueba?

Un **caso de prueba** es un conjunto de condiciones o variables bajo las cuales un probador determina si un sistema o una parte del mismo funciona correctamente.

---

## 🧰 Enfoques para diseñar casos de prueba

Existen dos grandes enfoques:

### 1. 🔍 Prueba de Caja Blanca (White Box)

👉 Diseña casos **basados en la estructura interna del código**.

- Se accede al **código fuente** para observar flujos de ejecución, condiciones, variables y bucles.
- Ideal para desarrolladores que quieren verificar caminos lógicos específicos del programa.

#### ⚙️ Técnicas comunes

| Técnica                         | Descripción                                                                 |
|----------------------------------|-----------------------------------------------------------------------------|
| **Prueba del Camino Básico**     | Asegura que **cada camino independiente** en el código se ejecuta al menos una vez. Se basa en la **complejidad ciclomatica**. |
| **Prueba de Estructura de Control** | Extiende el enfoque anterior y lo divide en:                              |
| - *Condiciones*                 | Ejercita **todas las decisiones y condiciones** del código.                 |
| - *Flujo de Datos*              | Sigue el rastro de **dónde se definen y usan las variables**.              |
| - *Bucles*                      | Analiza **distintos escenarios de ejecución de bucles** (0, 1, N veces).   |

---

### 2. 🎭 Prueba de Caja Negra (Black Box)

👉 Diseña casos de prueba **basándose en el comportamiento externo y los requisitos funcionales**.

- El probador **no conoce ni accede al código interno**.
- Solo se preocupa por las **entradas y salidas esperadas**.

#### 🧪 Técnicas comunes

| Técnica                         | Descripción                                                                 |
|----------------------------------|-----------------------------------------------------------------------------|
| **Métodos basados en grafos**    | Representan el comportamiento del sistema en forma de grafos.              |
| **Partición Equivalente**        | Divide las entradas en **clases equivalentes**, asumiendo comportamientos similares dentro de cada clase. |
| **Análisis de Valores Límite**   | Evalúa el sistema **justo en los límites de las entradas válidas**.        |
| **Prueba de Comparación**        | Compara **dos implementaciones independientes** con los mismos datos.      |
| **Tablas Ortogonales**           | Ideal para entradas limitadas. Cubre combinaciones usando **matrices ortogonales**. |

---

## 🧩 Relación con la Facilidad de Prueba

La **facilidad de prueba** influye directamente en qué tan sencillo o costoso es diseñar los casos de prueba.  
Un software con estas cualidades es **más fácil de probar**:

- **Simplicidad**: Menos código = menos caminos lógicos que verificar.
- **Facilidad de comprensión**: Facilita entender qué probar y cómo hacerlo.
- **Modularidad (descomposición)**: Permite probar unidades de forma aislada.
- **Controlabilidad**: Permite controlar el entorno de prueba y entradas.
- **Observabilidad**: Permite observar salidas y efectos fácilmente.

---

## ✅ Conclusión

> 🧠 El diseño de casos de prueba **es el núcleo de la ingeniería de pruebas**.  
> Combina lógica, estrategia y comprensión profunda del sistema para garantizar calidad.

---

🔁 *Recuerda: Caja Blanca y Caja Negra no son excluyentes — son enfoques **complementarios***.





---


# 🔁 Prueba del Camino Básico (extra)

> 💡 Técnica de **Caja Blanca** que se enfoca en probar la **lógica interna del código**.

## 🧠 ¿Qué es?

La **Prueba del Camino Básico** es una estrategia para diseñar casos de prueba que aseguren la ejecución de **todos los caminos lógicos independientes** dentro del código al menos una vez.

📌 *Cada camino representa una ruta diferente que puede seguir el flujo del programa*.

---

## 🔢 Herramienta clave: Complejidad Ciclomática

La **complejidad ciclomatica** es una métrica que te indica cuántos caminos independientes hay en un módulo de código.

Se calcula, por ejemplo, a partir del grafo de flujo de control del programa, y sirve para:

- Saber **cuántos casos de prueba necesitas como mínimo**.
- Evaluar la **complejidad lógica** del software.

---

	## 🛠️ ¿Cómo se aplica?
	
	1. 🔍 Se examina el código para identificar sus estructuras de control (if, while, for, etc.).
	2. 📈 Se representa el **flujo lógico** como un grafo.
	3. 📊 Se calcula la **complejidad ciclomatica (CC)**:
	   - Fórmula común: `CC = E - N + 2`, donde:
	     - E = número de aristas (transiciones),
	     - N = número de nodos (bloques de código).
	1. 🧪 Se diseñan casos de prueba que cubran **cada uno de esos caminos**.

## ✅ Ventajas

- Aumenta la cobertura del código.
- Reduce la probabilidad de errores lógicos no detectados.
- Es sistemática y cuantificable.
## ⚠️ Limitaciones

- **No es suficiente por sí sola**.
- No detecta errores de comportamiento (eso lo hace la Caja Negra).
- Puede ser difícil de aplicar si el código es muy complejo.

---

> 🔁 En resumen:  
> ✔️ **Usás la complejidad ciclomatica para contar caminos**,  
> ✔️ Y **diseñás un caso de prueba para cada uno**.  
> Es como asegurarte de recorrer **todas las rutas posibles** en el mapa del programa.


