
# ðŸ§ª TÃ©cnicas de Pruebas de Software

>[!NOTE]
> Basado en informaciÃ³n de distintas fuentes, a continuaciÃ³n te explico las tÃ©cnicas de pruebas de software de forma sencilla, clara y visual.

---

## ðŸ§· Â¿QuÃ© son las pruebas de software?

Las **pruebas de software** son un conjunto de actividades **planificadas y sistemÃ¡ticas** con el objetivo de **encontrar errores**.

> ðŸŽ¯ *Una buena prueba es aquella que tiene una alta probabilidad de encontrar un error.*

---

## ðŸ§° ClasificaciÃ³n de las TÃ©cnicas

Existen **dos categorÃ­as principales** de tÃ©cnicas para diseÃ±ar casos de prueba:

- ðŸ” **Caja Blanca**
- ðŸŽ­ **Caja Negra**

Ambas tÃ©cnicas nos guÃ­an sobre **cÃ³mo pensar para crear pruebas efectivas** que aseguren el buen funcionamiento del software.

---

## ðŸ” Prueba de Caja Blanca (o "Caja de Cristal")

> "Miramos **dentro del cÃ³digo**: cÃ³mo funciona internamente."

### ðŸ§  Â¿En quÃ© consiste?

- Se basa en la **estructura interna del programa**.
- Analiza decisiones (`if`, `switch`), bucles (`for`, `while`), etc.
- Su objetivo es **verificar los diferentes caminos lÃ³gicos del cÃ³digo**.
- TambiÃ©n permite examinar **el estado interno del programa**.

### ðŸ› ï¸ TÃ©cnicas de Caja Blanca

#### ðŸ” Prueba del Camino BÃ¡sico
- Asegura que **cada camino posible** dentro del cÃ³digo se ejecute al menos una vez.
- Se utiliza el concepto de **complejidad ciclomÃ¡tica** para contar los caminos bÃ¡sicos.

#### ðŸ§© Pruebas de Estructura de Control
- EvalÃºan las diferentes estructuras de decisiÃ³n y flujo del cÃ³digo:
  - ðŸ”¹ *Prueba de CondiciÃ³n*: verifica condiciones lÃ³gicas (`true/false`).
  - ðŸ”¹ *Prueba de Flujo de Datos*: sigue las **definiciones y usos de variables**.
  - ðŸ”¹ *Prueba de Bucles*: evalÃºa **distintos tipos de bucles** y sus comportamientos.

---

## ðŸŽ­ Prueba de Caja Negra (o "Prueba de Comportamiento")

> "Solo importa lo que el software **hace**, no cÃ³mo lo hace."

### ðŸ” Â¿En quÃ© consiste?

- No se analiza el cÃ³digo interno.
- Se basa en los **requisitos funcionales** del software.
- EvalÃºa **entradas y salidas** sin mirar la implementaciÃ³n.
- Se realiza a travÃ©s de la **interfaz del software**.

### ðŸ› ï¸ TÃ©cnicas de Caja Negra

#### ðŸ“ˆ Pruebas Basadas en Grafos
- Usan **diagramas** para modelar interacciones entre elementos del sistema.
- Muy Ãºtil para sistemas complejos.

#### ðŸ§ª ParticiÃ³n Equivalente
- Divide las entradas en **grupos equivalentes**.
- Basta con probar **una entrada por grupo**.

#### ðŸš§ AnÃ¡lisis de Valores LÃ­mite
- Prueba los valores **en los bordes del rango permitido**.
- Ejemplo: Si la entrada es de 1 a 100 â†’ probar 0, 1, 100, 101.

#### âš–ï¸ Prueba de ComparaciÃ³n
- Se usa en sistemas donde la **confiabilidad es crÃ­tica**.
- Consiste en comparar los resultados de **mÃºltiples versiones del software**.

#### ðŸ§® Prueba de la Tabla Ortogonal
- Mencionada como tÃ©cnica de caja negra.
- Utilizada para **cubrir combinaciones eficientes de datos de entrada**.

---

## âœ… Resumen Final

| TÃ©cnica       | Â¿QuÃ© observa?           | Â¿CÃ³mo prueba?                   |
|--------------|--------------------------|---------------------------------|
| ðŸ§  **Caja Blanca** | El cÃ³digo interno         | EvalÃºa caminos, bucles y condiciones |
| ðŸŽ­ **Caja Negra**  | El comportamiento externo | EvalÃºa entradas y salidas       |

---

> ðŸ“Œ **ConclusiÃ³n:** Las tÃ©cnicas de pruebas â€”ya sean de **caja blanca** o **caja negra**â€” son herramientas que te ayudan a **diseÃ±ar casos de prueba eficaces** para detectar errores y garantizar la calidad del software.

---

ðŸ§¡ *Probar es cuidar. Las pruebas no son para desconfiar del software, sino para proteger su calidad y fiabilidad.* ðŸ§¡






# ðŸ§ª Facilidad de Prueba (Testability)

---

## ðŸŽ¯ Â¿QuÃ© es la Facilidad de Prueba?

La **facilidad de prueba** â€”tambiÃ©n conocida como *testabilidad* o *comprobabilidad*â€” se refiere a:

> ðŸ§© **QuÃ© tan fÃ¡cil es probar un programa de software**.

Es decir, mide el **esfuerzo requerido** para verificar que un sistema o mÃ³dulo realiza correctamente las funciones que se espera que realice.

> ðŸ› ï¸ *Un software con alta facilidad de prueba facilita la detecciÃ³n y correcciÃ³n de errores.*

---

## ðŸ—ï¸ Â¿Por quÃ© es importante?

ðŸ”¸ La facilidad de prueba **debe considerarse desde el diseÃ±o e implementaciÃ³n** del software.  
ðŸ”¸ Ayuda a construir **software mantenible y confiable**.  
ðŸ”¸ Reduce el tiempo y costo en **etapas posteriores** del ciclo de vida.

---

## ðŸ“‹ CaracterÃ­sticas de un Software FÃ¡cil de Probar

A continuaciÃ³n, las propiedades que mejoran la facilidad de prueba en un sistema:

| ðŸ§± CaracterÃ­stica            | ðŸ“Œ DescripciÃ³n                                                                 |
|-----------------------------|---------------------------------------------------------------------------------|
| âœ… **Simplicidad**           | Menos complejidad = pruebas mÃ¡s rÃ¡pidas y sencillas.                           |
| ðŸ” **Facilidad de ComprensiÃ³n** | A mayor comprensiÃ³n del sistema, mejores decisiones al diseÃ±ar pruebas.       |
| ðŸ§© **Capacidad de DescomposiciÃ³n** | Permite dividir el software en **mÃ³dulos independientes** para probar por separado. |
| ðŸŽ® **Controlabilidad**       | Posibilidad de **controlar los datos y estados** durante las pruebas.          |
| ðŸ‘ï¸ **Observabilidad**       | Capacidad de **ver resultados y comportamientos** del sistema durante la prueba.|

---

## ðŸ§¾ Resumen

> La **facilidad de prueba** es una propiedad clave de calidad que indica:

ðŸŽ¯ **Â¿CuÃ¡nto trabajo cuesta verificar que un software funciona correctamente?**

ðŸ§  *Un software bien diseÃ±ado no solo funciona... tambiÃ©n se deja probar.* ðŸ’¡





----




# ðŸ§ª DiseÃ±o de Casos de Prueba

> ðŸ’¡ **DiseÃ±ar un caso de prueba** es preparar una situaciÃ³n para evaluar si el software cumple con un requisito especÃ­fico.  
> Las tÃ©cnicas de prueba son precisamente **estrategias para diseÃ±ar estos casos de manera eficaz**.

---

## ðŸŽ¯ Â¿QuÃ© es un caso de prueba?

Un **caso de prueba** es un conjunto de condiciones o variables bajo las cuales un probador determina si un sistema o una parte del mismo funciona correctamente.

---

## ðŸ§° Enfoques para diseÃ±ar casos de prueba

Existen dos grandes enfoques:

### 1. ðŸ” Prueba de Caja Blanca (White Box)

ðŸ‘‰ DiseÃ±a casos **basados en la estructura interna del cÃ³digo**.

- Se accede al **cÃ³digo fuente** para observar flujos de ejecuciÃ³n, condiciones, variables y bucles.
- Ideal para desarrolladores que quieren verificar caminos lÃ³gicos especÃ­ficos del programa.

#### âš™ï¸ TÃ©cnicas comunes

| TÃ©cnica                         | DescripciÃ³n                                                                 |
|----------------------------------|-----------------------------------------------------------------------------|
| **Prueba del Camino BÃ¡sico**     | Asegura que **cada camino independiente** en el cÃ³digo se ejecuta al menos una vez. Se basa en la **complejidad ciclomatica**. |
| **Prueba de Estructura de Control** | Extiende el enfoque anterior y lo divide en:                              |
| - *Condiciones*                 | Ejercita **todas las decisiones y condiciones** del cÃ³digo.                 |
| - *Flujo de Datos*              | Sigue el rastro de **dÃ³nde se definen y usan las variables**.              |
| - *Bucles*                      | Analiza **distintos escenarios de ejecuciÃ³n de bucles** (0, 1, N veces).   |

---

### 2. ðŸŽ­ Prueba de Caja Negra (Black Box)

ðŸ‘‰ DiseÃ±a casos de prueba **basÃ¡ndose en el comportamiento externo y los requisitos funcionales**.

- El probador **no conoce ni accede al cÃ³digo interno**.
- Solo se preocupa por las **entradas y salidas esperadas**.

#### ðŸ§ª TÃ©cnicas comunes

| TÃ©cnica                         | DescripciÃ³n                                                                 |
|----------------------------------|-----------------------------------------------------------------------------|
| **MÃ©todos basados en grafos**    | Representan el comportamiento del sistema en forma de grafos.              |
| **ParticiÃ³n Equivalente**        | Divide las entradas en **clases equivalentes**, asumiendo comportamientos similares dentro de cada clase. |
| **AnÃ¡lisis de Valores LÃ­mite**   | EvalÃºa el sistema **justo en los lÃ­mites de las entradas vÃ¡lidas**.        |
| **Prueba de ComparaciÃ³n**        | Compara **dos implementaciones independientes** con los mismos datos.      |
| **Tablas Ortogonales**           | Ideal para entradas limitadas. Cubre combinaciones usando **matrices ortogonales**. |

---

## ðŸ§© RelaciÃ³n con la Facilidad de Prueba

La **facilidad de prueba** influye directamente en quÃ© tan sencillo o costoso es diseÃ±ar los casos de prueba.  
Un software con estas cualidades es **mÃ¡s fÃ¡cil de probar**:

- **Simplicidad**: Menos cÃ³digo = menos caminos lÃ³gicos que verificar.
- **Facilidad de comprensiÃ³n**: Facilita entender quÃ© probar y cÃ³mo hacerlo.
- **Modularidad (descomposiciÃ³n)**: Permite probar unidades de forma aislada.
- **Controlabilidad**: Permite controlar el entorno de prueba y entradas.
- **Observabilidad**: Permite observar salidas y efectos fÃ¡cilmente.

---

## âœ… ConclusiÃ³n

> ðŸ§  El diseÃ±o de casos de prueba **es el nÃºcleo de la ingenierÃ­a de pruebas**.  
> Combina lÃ³gica, estrategia y comprensiÃ³n profunda del sistema para garantizar calidad.

---

ðŸ” *Recuerda: Caja Blanca y Caja Negra no son excluyentes â€” son enfoques **complementarios***.





---


# ðŸ” Prueba del Camino BÃ¡sico (extra)

> ðŸ’¡ TÃ©cnica de **Caja Blanca** que se enfoca en probar la **lÃ³gica interna del cÃ³digo**.

## ðŸ§  Â¿QuÃ© es?

La **Prueba del Camino BÃ¡sico** es una estrategia para diseÃ±ar casos de prueba que aseguren la ejecuciÃ³n de **todos los caminos lÃ³gicos independientes** dentro del cÃ³digo al menos una vez.

ðŸ“Œ *Cada camino representa una ruta diferente que puede seguir el flujo del programa*.

---

## ðŸ”¢ Herramienta clave: Complejidad CiclomÃ¡tica

La **complejidad ciclomatica** es una mÃ©trica que te indica cuÃ¡ntos caminos independientes hay en un mÃ³dulo de cÃ³digo.

Se calcula, por ejemplo, a partir del grafo de flujo de control del programa, y sirve para:

- Saber **cuÃ¡ntos casos de prueba necesitas como mÃ­nimo**.
- Evaluar la **complejidad lÃ³gica** del software.

---

	## ðŸ› ï¸ Â¿CÃ³mo se aplica?
	
	1. ðŸ” Se examina el cÃ³digo para identificar sus estructuras de control (if, while, for, etc.).
	2. ðŸ“ˆ Se representa el **flujo lÃ³gico** como un grafo.
	3. ðŸ“Š Se calcula la **complejidad ciclomatica (CC)**:
	   - FÃ³rmula comÃºn: `CC = E - N + 2`, donde:
	     - E = nÃºmero de aristas (transiciones),
	     - N = nÃºmero de nodos (bloques de cÃ³digo).
	1. ðŸ§ª Se diseÃ±an casos de prueba que cubran **cada uno de esos caminos**.

## âœ… Ventajas

- Aumenta la cobertura del cÃ³digo.
- Reduce la probabilidad de errores lÃ³gicos no detectados.
- Es sistemÃ¡tica y cuantificable.
## âš ï¸ Limitaciones

- **No es suficiente por sÃ­ sola**.
- No detecta errores de comportamiento (eso lo hace la Caja Negra).
- Puede ser difÃ­cil de aplicar si el cÃ³digo es muy complejo.

---

> ðŸ” En resumen:  
> âœ”ï¸ **UsÃ¡s la complejidad ciclomatica para contar caminos**,  
> âœ”ï¸ Y **diseÃ±Ã¡s un caso de prueba para cada uno**.  
> Es como asegurarte de recorrer **todas las rutas posibles** en el mapa del programa.


