
# 🧩 Pruebas de Estructura de Control

> ⚙️ Son un subconjunto de las **pruebas de caja blanca** que se enfocan en verificar el **flujo de control interno** del software.

---

## 🧠 ¿Qué son?

Aunque el término "pruebas de estructura de control" no está definido explícitamente en todas las fuentes, se entiende como aquellas **pruebas internas que analizan la lógica de control del código**, típicas de la **prueba de caja blanca**.

---

## 🔍 Relación con la Prueba de Caja Blanca

Las **pruebas de estructura de control**:
- Se basan en **"meterse dentro del código"** para diseñar casos de prueba.
- Evalúan decisiones, bucles, condiciones y bifurcaciones internas del programa.
- Se oponen a la prueba de caja negra, que evalúa solo la entrada y salida del sistema.

---

## 🧱 Ubicación en el Proceso de Desarrollo

### 📐 Modelo en V
- El **modelo en V** relaciona etapas de desarrollo con sus respectivas pruebas.
- Las pruebas de estructura de control se aplican en:
  - 🔸 **Pruebas unitarias**
  - 🔸 Fase de **construcción** (codificación + pruebas)
- Su objetivo es validar la **base de la pirámide de calidad** del software.

### 🕓 Principio "Shift Left"
- Detectar errores **temprano = menor costo**.
- Las pruebas de estructura de control contribuyen a:
  - 🪛 Corregir antes de producción.
  - 🪜 Evitar acumulación de defectos.
  - 📉 Reducir los costos según la **Curva de Boehm**.

---

## 🔄 Relación con la Integración de Módulos

### ⬆️ Integración Ascendente
- Se empieza por probar módulos atómicos de bajo nivel.
- Ventajas:
  - ✔️ Permite probar antes las **funciones de control**.
  - ✔️ Simplifica casos de prueba: **no requiere stubs** una vez que los módulos básicos están listos.
  - ✔️ Facilita el análisis de **módulos críticos**, con alto control o complejidad.

---

## ✅ En resumen

Las **pruebas de estructura de control**:
- Son **pruebas de caja blanca** que verifican la lógica interna.
- Son clave en las **etapas tempranas** del desarrollo.
- Apoyan la estrategia de **"Shift Left"**.
- Mejoran la **calidad y mantenibilidad** del software.

> 🧪 Se enfocan en asegurar que **cada camino de control y decisión del código se comporta como se espera**.


# 🧪 Pruebas de Condición, Flujo de Datos y Bucles

> Estas pruebas son distintas formas de **revisar el interior del programa**: el código. Son parte de las **pruebas de caja blanca**, donde miramos *cómo* funciona el software por dentro, no solo *qué hace*.

Sirven para **detectar errores lógicos** que no se verían desde afuera, y elegimos cuál usar dependiendo de:
- 🤯 La complejidad del código
- 🕒 El tiempo disponible
- 👥 Los recursos humanos que tenemos

---

## 🧾 Prueba de Condición

🎯 **Objetivo:** Verificar que cada condición lógica o regla del programa funcione por separado.

💡 **Ejemplo:**  
Si en un juego la regla es:  
```si tenés más de 10 puntos, ganás```,  
esta prueba comprueba que esa condición se cumpla correctamente, sin importar el camino que se haya seguido.

🔍 Se enfoca en:
- Condiciones simples (`if`, `else`, `switch`)
- Evaluar cada posible resultado de una condición, de forma aislada

---

## 🧬 Prueba de Flujo de Datos

🎯 **Objetivo:** Seguir el recorrido de las **variables** en el código, desde que se **definen** hasta que se **usan**.

💡 **Ejemplo:**  
Como seguir el azúcar desde que la sacás de la alacena (la definís) hasta que la usás en la torta (la utilizás en una operación).

🔍 Se enfoca en:
- Variables mal inicializadas o sin usar
- Uso de datos sin definir
- Rutas de código que no actualizan correctamente los valores

---

## 🔁 Prueba de Bucles

🎯 **Objetivo:** Evaluar cómo se comportan los **bucles** (estructuras repetitivas) en diferentes escenarios.

💡 **Ejemplo:**  
Como probar saltar la soga:
- 🪂 Una sola vez
- 🔁 Varias veces
- 🛑 Hasta el límite

🔍 Se enfoca en:
- Ejecución **cero veces** (¿el bucle puede no ejecutarse?)
- Ejecución **una vez**
- Ejecución **varias veces**
- Casos **límite o extremos** (por ejemplo, con el máximo de iteraciones)

---

## ✅ En resumen

| Tipo de prueba        | ¿Qué revisa?                             | ¿Para qué sirve?                             |
|-----------------------|------------------------------------------|----------------------------------------------|
| 🧾 Condición          | Las **reglas** o decisiones del código   | Ver que cada condición funcione correctamente|
| 🧬 Flujo de datos     | El **uso de variables** en el tiempo     | Detectar errores de inicialización y uso     |
| 🔁 Bucles             | Las **estructuras repetitivas**          | Ver que se comporten bien en todos los casos |

> 🧠 Todas son esenciales en pruebas de caja blanca para asegurar que el código **funciona como se espera internamente**.





# 🧱 Pruebas de Caja Negra (o Pruebas de Comportamiento)

> 📦 Imaginá que tenés un **juguete nuevo** y no sabés qué tiene adentro. Solo podés probarlo **apretando botones** y viendo cómo responde.  
Eso es una **prueba de caja negra**: no importa cómo funciona por dentro, solo te importa **lo que hace**.

---

## 🎯 ¿Qué es una Prueba de Caja Negra?

- Es un tipo de prueba en el que **no se mira el código fuente**.
- Se enfoca exclusivamente en la **entrada** y la **salida esperada** del software.
- Busca confirmar que el sistema **cumple con los requisitos funcionales**.

🧪 **Ejemplo:**  
Ingresás un número en una calculadora. No te importa cómo hace la cuenta internamente, solo querés saber si **el resultado es correcto**.

---

## 🛠️ Características Principales

- ✅ Evalúa si el software **hace lo que debe hacer**.
- 🚫 No considera el diseño interno ni la lógica del código.
- 🧑‍💻 Se realiza sobre la **interfaz del sistema** (inputs/outputs).
- 🤝 Complementa a las pruebas de caja blanca (¡no la reemplaza!).
- 🔄 A medida que el software madura, **se incrementan las pruebas de caja negra**.

---

## 📐 Técnicas para diseñar pruebas de Caja Negra

### 🔳 Partición Equivalente
- Divide los datos de entrada en **grupos válidos e inválidos**.
- Se prueba un caso representativo por grupo.

> ✨ Ejemplo: Si el sistema acepta edades entre 18 y 65, probás con:
> - Un valor dentro del rango (✅)
> - Uno menor a 18 (❌)
> - Uno mayor a 65 (❌)

---

### 📏 Análisis de Valores Límite
- Se prueba con valores **en los bordes del rango permitido**.

> ✨ Ejemplo:  
> Si una función acepta valores de 1 a 100:
> - Probás con 1 (mínimo aceptado)  
> - Probás con 100 (máximo aceptado)  
> - Probás con 0 y 101 (valores límite no válidos)

---

### 🔁 Prueba de Comparación
- Se ejecutan **múltiples versiones del software** con los mismos datos para ver si los resultados coinciden.

---

### 🧮 Métodos basados en Grafos
- Se modela el comportamiento del sistema como un **grafo de estados y transiciones**, probando distintos caminos posibles.

---

## 🚗 ¿Caja Blanca vs. Caja Negra?

| Tipo de Prueba      | ¿Qué se mira?              | ¿Cómo se hace?                          |
|---------------------|-----------------------------|------------------------------------------|
| ⚪ Caja Blanca       | El **interior del código**  | Revisando lógica, bucles, condiciones    |
| ⚫ Caja Negra        | El **comportamiento externo**| Usando entradas/salidas esperadas        |

---

## ✅ En resumen

> Si la **caja blanca** es como revisar el motor de un auto...  
> la **caja negra** es como **subirte, manejarlo y ver si funciona bien**.

Ambas pruebas son **complementarias** y fundamentales para garantizar la **calidad del software** desde diferentes ángulos.  




# ⚫ Métodos de Pruebas de Caja Negra

Las **pruebas de caja negra** se centran en verificar si el software cumple con sus **requisitos funcionales**, sin mirar el código. Se ejecutan desde la **interfaz** del sistema y se complementan con las pruebas de caja blanca.

## 🧪 Objetivo general

- Evaluar si el sistema **responde correctamente a distintas entradas**.
- Detectar errores como:
  - Funciones incorrectas o faltantes.
  - Problemas de interfaz.
  - Errores en estructuras de datos externas o bases de datos.
  - Desvíos respecto a requisitos.

---

## 🔍 Métodos para diseñar casos de prueba de caja negra

### 1. 🗺️ **Métodos Basados en Grafos**

> **Analizan la estructura del sistema como un grafo (nodos + conexiones)**.

- Se visualiza el software como un **mapa conceptual**, donde:
  - Los **nodos** representan entidades, procesos, pantallas, etc.
  - Las **aristas** representan la transición o comunicación entre ellos.
- Permite:
  - Diseñar rutas que simulan distintos recorridos de uso.
  - Detectar fallos en la lógica de navegación o flujo de trabajo.

📌 *Ideal para sistemas complejos o distribuidos.*

---

### 2. 🍬 **Partición Equivalente**

> Divide el dominio de entrada en **clases que se comportan de forma similar**.

🧠 Idea clave: **Si una entrada de una clase funciona bien, se asume que las demás también.**

- Tipos de clases:
  - **Válidas**: deben producir una salida correcta.
  - **Inválidas**: deben ser rechazadas o generar error controlado.
  
📌 *Reduce la cantidad de pruebas sin perder cobertura.*

🧾 **Ejemplo**:
- Entrada válida: monedas entre $1 y $10.
- Entrada inválida: billetes, monedas rotas, etc.
- Se prueba **una entrada representativa por clase**.

---

### 3. 📏 **Análisis de Valores Límite**

> Se enfoca en los **bordes del dominio válido**: donde suelen aparecer errores.

- Se prueban:
  - Los **límites inferiores y superiores** válidos.
  - Justo **por debajo y por encima** de esos límites.

🧾 **Ejemplo**:
- Rango válido: 1 a 100.
- Casos a probar: `0`, `1`, `2`, `99`, `100`, `101`.

📌 *Complementa la partición equivalente con pruebas más precisas.*

---

### 4. 🧪 **Prueba de Comparación**

> Se ejecutan **dos o más versiones** del software con los mismos datos para **comparar resultados**.

🎯 Útil cuando:
- Se está migrando de versión.
- Existen múltiples implementaciones (ej. paralelas o por diferentes proveedores).

📌 *Ayuda a detectar desviaciones funcionales críticas.*

---

### 5. 🧮 **Prueba de la Tabla Ortogonal**

> Diseñada para manejar **muchas combinaciones posibles de entradas** sin probarlas todas.

- Usa principios matemáticos (diseño ortogonal) para seleccionar un **conjunto mínimo de combinaciones representativas**.
- Maximiza la cobertura con **menos casos de prueba**.

🧾 **Ejemplo**:
- 4 parámetros, cada uno con 3 posibles valores = 81 combinaciones.
- Tabla ortogonal puede reducir eso a 9 pruebas clave sin perder efectividad.

📌 *Ideal para configuraciones de entrada múltiples o pruebas de compatibilidad.*

---

## 📌 En resumen

| Método                      | ¿Para qué sirve?                              | Ejemplo simple                        |
|----------------------------|-----------------------------------------------|---------------------------------------|
| 🔳 Partición Equivalente    | Probar por grupos de entradas similares       | Monedas válidas / inválidas           |
| 📏 Análisis de Límites      | Ver qué pasa en los bordes del rango          | $1, $10, $0.99, $10.01                |
| 🗺️ Basado en Grafos         | Explorar rutas posibles del sistema           | Menú → Submenú → Acción               |
| 🧪 Comparación               | Ver si varias versiones dan el mismo resultado| Comparar dos calculadoras             |
| 🧮 Tabla Ortogonal           | Probar muchas combinaciones con pocos casos   | Parámetros de configuración múltiples |

---

## ✅ Conclusión

> Las pruebas de caja negra permiten verificar el **comportamiento funcional del sistema sin conocer su código fuente**.  
> Son una herramienta **clave para garantizar la calidad del software**, especialmente desde el punto de vista del usuario.












# 🧪 Comparación entre Pruebas de Caja Blanca y Caja Negra

Las pruebas de software son fundamentales para garantizar la calidad del producto. Entre las más importantes se encuentran las **pruebas de caja blanca** y las **pruebas de caja negra**. A continuación, exploramos sus diferencias, objetivos y técnicas, así como cómo se complementan entre sí.

---

## 🔍 ¿Qué son las pruebas de caja blanca?

Imaginá que tenés un coche y abrís el capó para ver cómo está conectado el motor, los cables y las bujías. Esa es la idea detrás de las pruebas de caja blanca.

### 🎯 Características principales

- **🔧 Perspectiva interna:** Se examina la lógica y estructura interna del código fuente.
- **🧠 Requiere conocimientos técnicos:** El probador debe tener acceso al código y entender su lógica, estructuras de datos y flujo de control.
- **✅ Objetivo:** Verificar que todos los **caminos lógicos** se ejecutan al menos una vez, y que el estado del programa es correcto en puntos clave.
- **📍 Aplicación típica:** Pruebas unitarias y, a veces, de integración a bajo nivel.

### 🛠️ Técnicas comunes

- **Prueba del camino básico:** Asegura que todos los caminos independientes del programa se ejecuten.
- **Prueba de condiciones:** Evalúa todas las combinaciones lógicas de condiciones.
- **Prueba de flujo de datos:** Analiza el uso de variables (dónde se definen y dónde se usan).
- **Prueba de bucles:** Evalúa bucles con diferentes cantidades de iteraciones (cero, una, muchas).

---

## 🧭 ¿Qué son las pruebas de caja negra?

Ahora imaginá que usás el coche sin abrir el capó: encendés el motor, probás si arranca, si dobla, si frena… así funcionan las pruebas de caja negra.

### 🎯 Características principales

- **🔒 Perspectiva externa:** El sistema se trata como una caja cerrada. Se evalúan entradas y salidas sin conocer el código interno.
- **👥 No requiere conocimiento del código:** Se basa en los requisitos funcionales del sistema.
- **✅ Objetivo:** Verificar que el software **cumple sus requisitos funcionales**. Se observa cómo responde ante entradas válidas e inválidas.
- **📍 Aplicación típica:** Pruebas de validación, pruebas de sistema, integración de alto nivel.

### 🛠️ Técnicas comunes

- **Partición de equivalencia:** Agrupa entradas similares que deberían comportarse igual.
- **Análisis de valores límites:** Evalúa entradas en los extremos de los rangos permitidos.
- **Métodos basados en grafos:** Representan la interacción entre componentes o flujos.
- **Prueba de comparación:** Evalúa si múltiples implementaciones generan los mismos resultados.
- **Tablas ortogonales:** Selecciona combinaciones representativas en dominios de entrada complejos.

---

## 🆚 Tabla comparativa

| Característica              | 🧪 Caja Blanca                        | 🎭 Caja Negra                               |
|----------------------------|--------------------------------------|---------------------------------------------|
| Perspectiva                | Interna (estructura del código)      | Externa (funcionalidad observable)          |
| Conocimiento del código    | Requiere                             | No requiere                                 |
| Qué se prueba              | Lógica, flujo, condiciones, bucles   | Entradas, salidas, comportamiento esperado  |
| Nivel de aplicación        | Bajo (unidad, integración interna)   | Alto (sistema, validación, interfaz)        |
| Quién la realiza           | Desarrolladores                      | Testers, QA, usuarios finales               |
| Errores que detecta        | Lógicos, estructurales, rutas no cubiertas | Requisitos no cumplidos, respuestas erróneas, fallos en interfaz |
| Técnicas típicas           | Camino básico, bucles, flujo de datos| Partición, límites, comparación, grafos     |

---

## 🤝 ¿Se usan juntas?

¡Sí! Las pruebas de caja blanca y negra no son excluyentes, sino **complementarias**:

- 🔄 **Caja blanca** detecta errores de **implementación**.
- 🎯 **Caja negra** detecta errores de **especificación** y fallas de comportamiento.

> 🔐 Mientras la prueba de caja blanca asegura que el motor funciona correctamente, la prueba de caja negra verifica que el coche haga lo que el usuario espera.

---
## 🧠 Conclusión

Combinar ambos tipos de pruebas permite una visión integral del sistema:

- Asegura la **calidad interna del código**.
- Valida el **cumplimiento de los requisitos funcionales**.
- Ofrece **mayor cobertura de errores** en todo el ciclo de vida del software.







# ✅ Verificación vs Validación en Ingeniería de Software

En el desarrollo de software, asegurar la calidad del producto implica más que simplemente probar el código. Esto se logra mediante un proceso conocido como **Verificación y Validación (V&V)**, del cual las pruebas de software son solo una parte.

---

## 🛠️ ¿Qué es la Verificación?

> **Pregunta clave:** *¿Construimos el producto correctamente?*

### 📌 Definición
La **verificación** es el proceso que garantiza que el software **cumple con sus especificaciones técnicas**. Se centra en asegurar que cada componente del sistema funcione conforme a lo diseñado.

### 🔎 Enfoque
- Verifica la **exactitud técnica de la implementación**.
- Implica revisar si el **código y los procesos internos** cumplen lo esperado.

### 🧪 Ejemplos de actividades
- Revisión de código fuente
- Análisis de complejidad
- Pruebas unitarias
- Revisión de documentación técnica
- Auditorías de calidad

---

## 🎯 ¿Qué es la Validación?

> **Pregunta clave:** *¿Construimos el producto correcto?*

### 📌 Definición
La **validación** asegura que el producto **cumple con los requerimientos del usuario o cliente final**. Se trata de confirmar que lo desarrollado realmente resuelve el problema para el cual fue creado.

### 🔎 Enfoque
- Se centra en el **comportamiento externo y funcional** del sistema.
- Evalúa si el software **satisface las necesidades reales del usuario**.

### 🧪 Ejemplos de actividades
- Pruebas de aceptación del usuario
- Pruebas de sistema
- Demostraciones al cliente
- Simulaciones y prototipos funcionales

---

## 🔄 Diferencias clave

| Aspecto                  | 🔧 Verificación                         | 👥 Validación                                |
|--------------------------|----------------------------------------|---------------------------------------------|
| Enfoque principal        | Técnicamente correcto                  | Funcionalmente correcto                      |
| Pregunta que responde    | ¿Lo hicimos bien?                      | ¿Hicimos lo que el cliente quería?          |
| Perspectiva              | Interna (desarrollo y calidad)         | Externa (usuario final)                     |
| Acceso al código         | Sí                                     | No necesariamente                           |
| Ejemplos típicos         | Revisiones, análisis estático, pruebas unitarias | Pruebas de aceptación, validación de requisitos |
| Momento de aplicación    | Durante el desarrollo                  | Al final del desarrollo / antes del despliegue |

---

## 💬 Metáfora para recordar

> 🏗️ *Verificación es como revisar si construimos correctamente cada ladrillo del edificio (estructura técnica). Validación es comprobar si ese edificio es lo que el cliente quería: con balcón, con luz natural, y en el barrio correcto.* 🧍‍♂️🏙️

---

## 🔁 V&V en el ciclo de vida moderno

En prácticas modernas como **DevOps**, **Integración Continua (CI)** y **Entrega Continua (CD)**:

- V&V no es un paso final, sino una actividad **continua**.
- Las herramientas automáticas permiten verificar y validar de forma constante.
- Se integran prácticas como:
  - **Tests automáticos en cada commit**
  - **Simulación en entornos controlados**
  - **Feedback temprano del usuario**

---

## 🧠 Conclusión

- **Verificación**: Garantiza que el producto está bien construido según lo especificado.
- **Validación**: Asegura que el producto es útil y adecuado para el usuario.

Ambos enfoques son **complementarios** y necesarios para lograr software de alta calidad.

> 📌 **No alcanza con que funcione; tiene que funcionar para lo que fue pensado.**





# 🧪 Verificación y Validación (V&V) + Pirámide de Pruebas

La **Verificación y Validación (V&V)** es un conjunto de actividades esenciales en la ingeniería de software para garantizar la calidad del producto. Las **pruebas de software** son parte fundamental de este proceso.

---

## ✅ Diferencia entre Verificación y Validación

| Concepto      | Verificación                                                | Validación                                                   |
|---------------|-------------------------------------------------------------|--------------------------------------------------------------|
| ¿Qué pregunta responde? | **¿Construimos el producto correctamente?**         | **¿Construimos el producto correcto?**                      |
| Enfoque       | Exactitud técnica de la implementación                      | Conformidad con los requisitos del cliente                   |
| Actividades   | Revisión de código, análisis estático, pruebas unitarias... | Pruebas de aceptación, validación de funcionalidades visibles |
| Tipo de pruebas | Más orientado a **caja blanca**                            | Más orientado a **caja negra**                              |
| Nivel         | Interno al desarrollo                                        | Orientado al cliente/usuario final                          |

---

## 🧱 Pirámide de Pruebas y su Relación con el Modelo en V

La **pirámide de pruebas** representa la jerarquía ideal en la cantidad y tipo de pruebas que se deben realizar:

```
    🔺 Pruebas de Aceptación (Validación)
   🔺🔺 Pruebas de Sistema
  🔺🔺🔺 Pruebas de Integración
 🔺🔺🔺🔺 Pruebas Unitarias (Verificación)
```

Estas pruebas se relacionan con las fases del **Modelo en V**:

---

### 1. 🧪 Pruebas Unitarias (Unit Tests)
- **Fase del Modelo en V**: Generación de código
- **Descripción**: Prueban funciones/módulos individuales.
- **Tipo**: Caja blanca
- **Responsable**: Desarrollador
- **Objetivo**: Validar que cada componente funcione por sí solo.

---

### 2. 🔗 Pruebas de Integración
- **Fase del Modelo en V**: Diseño de componentes
- **Descripción**: Prueban la interacción entre módulos.
- **Tipo**: Caja negra (principalmente) y caja blanca (complementariamente)
- **Estrategias**:
  - Integración descendente (top-down)
  - Integración ascendente (bottom-up)

---

### 3. 🖥️ Pruebas de Sistema
- **Fase del Modelo en V**: Diseño de la arquitectura
- **Descripción**: Se prueba el sistema como un todo junto con otros elementos (hardware, redes, etc.)
- **Tipo**: Caja negra
- **Ejemplos**: Pruebas de rendimiento, estrés, seguridad, recuperación, etc.

---

### 4. 👥 Pruebas de Aceptación / Validación
- **Fase del Modelo en V**: Modelado de requerimientos
- **Descripción**: Evalúan si el sistema cumple con las necesidades del cliente.
- **Tipo**: Caja negra
- **Responsable**: Cliente/usuario final
- **Objetivo**: Confirmar que se construyó el producto adecuado.

---

## 📈 Importancia de Probar Temprano

- La **curva de Boehm** muestra que **los errores son más costosos cuanto más tarde se detectan**.
- La estrategia de la pirámide impulsa una **calidad desde el inicio**, con énfasis en pruebas automáticas y frecuentes.
- En metodologías modernas como **CI/CD o DevOps**, V&V se realiza **continuamente** durante todo el ciclo de vida.

---

## 🔄 Relación con V&V

- La pirámide se integra dentro del enfoque global de **Verificación y Validación**:
  - **Verificación**: ¿Lo hicimos bien? (foco técnico)
  - **Validación**: ¿Hicimos lo que el cliente quería? (foco funcional)

---

## 📌 Conclusión

La aplicación adecuada de la pirámide de pruebas y el modelo en V asegura un proceso de desarrollo más eficiente, menos costoso y centrado en la calidad. **Probar pronto, probar con frecuencia y probar bien** es clave para el éxito del software.



# 🧩 Pruebas de Integración

Las **pruebas de integración** son un nivel crucial en la jerarquía de la **pirámide de pruebas** y del ciclo de vida del desarrollo de software. Su objetivo principal es **verificar cómo funcionan los diferentes módulos o componentes del software cuando se combinan**.

---

## 🎯 Propósito y Enfoque

- Se ejecutan **después de las pruebas unitarias**, cuando los componentes individuales ya fueron verificados.
- Abordan el **problema de la conexión entre módulos**, es decir, asegurar que funcionen correctamente en conjunto.
- Se centran en:
  - El **diseño de la arquitectura del software**.
  - La **verificación de interfaces** y la correcta construcción de programas.

---

## 🧪 Técnicas de Prueba Utilizadas

- **Caja negra**: Enfocadas en entradas/salidas, sin considerar la lógica interna.
- **Caja blanca**: A veces se usan para examinar rutas específicas del código y lograr mayor cobertura.

---

## 🔄 Estrategias de Prueba de Integración

Evitar la integración **no incremental** (integrar todo de golpe), ya que dificulta el diagnóstico de errores.

### ✅ Se prefiere la integración **incremental**, que permite:

- Aislar y corregir errores más fácilmente.
- Probar interfaces de manera controlada.
- Mantener una construcción sistemática del software.

---

### 🔽 Integración Descendente (Top-Down)

- Se comienza por el **módulo principal**, agregando luego los subordinados.
- Dos variantes: **por profundidad** o **por anchura**.
- Se utilizan **stubs** (simulaciones de módulos aún no implementados).

**Ventajas**:
- Permite probar las funciones de control centrales desde el inicio.

**Desventajas**:
- Los stubs pueden dificultar la identificación de errores específicos.
- Se pierde precisión en la correlación entre pruebas y errores.

---

### 🔼 Integración Ascendente (Bottom-Up)

- Se comienza desde los **módulos más bajos** (atómicos) y se va hacia arriba.
- No requiere stubs, ya que los módulos inferiores están ya probados.

**Ventajas**:
- Facilita el diseño de casos de prueba.
- Mejora el control sobre el proceso de integración.

**Desventajas**:
- El sistema completo no está disponible hasta que se ensamblan los niveles superiores.

---

## 🔁 Relación con la Integración Continua

- La **integración continua (CI)** es una práctica ágil que fomenta integrar código frecuentemente (idealmente, a diario).
- Cada integración se valida automáticamente mediante una **build automatizada** que incluye pruebas automatizadas (unitarias e integración).
- Objetivo: **detectar y resolver errores lo antes posible**, reduciendo el costo de las fallas detectadas tardíamente.

---

## 🧠 Resumen

> Las pruebas de integración aseguran que los **módulos funcionan bien en conjunto**, mientras que la integración incremental y continua permite detectar errores en las interfaces **temprano y frecuentemente**, lo cual es esencial para una arquitectura de software robusta y escalable.







# 🚬 Prueba de Humo (Smoke Test)

La **prueba de humo** es una prueba inicial que se ejecuta **después de compilar una build del software**, con el objetivo de **verificar que las funcionalidades básicas y críticas funcionen correctamente**.

---

## 🎯 Propósito Principal

- Detectar de forma temprana si los elementos más importantes del sistema **no funcionan**.
- Verificar aspectos fundamentales como:
  - Que la aplicación **se inicie correctamente**.
  - Que las **conexiones y accesos** (como el login) funcionen.
  - Que los **botones y funciones clave** respondan como se espera.

---

## 🧭 Alcance

- Debe **ejercitar todo el sistema de extremo a extremo**, aunque de forma superficial.
- No busca ser exhaustiva, sino **exponer errores graves rápidamente**.
- Se centra en probar lo más propenso a fallar:
  - Funciones críticas.
  - Procesos esenciales.
- Permite suponer que, si pasa la prueba de humo, la build es **lo suficientemente estable para pruebas más profundas**.

---

## 🧪 Casos de Prueba

1. Identificar las funcionalidades **básicas y críticas** que debe cumplir el producto.
2. Diseñar casos de prueba para esas funcionalidades.
3. Ejecutar esta suite de pruebas **con cada nueva build**.
4. Estas pruebas pueden incluir:
   - Pruebas funcionales.
   - Pruebas unitarias.
   - Pruebas de sistema.

---

## 🔁 En Integración Continua (CI)

- Las pruebas de humo **automatizadas** se ejecutan **automáticamente** con cada nueva build.
- Actúan como **filtro rápido** para asegurar que los desarrollos recientes no rompan las funciones esenciales.

---

## ✅ Ventajas

- 🔍 **Detección temprana de errores**, especialmente en entornos de integración continua.
- 🧩 **Reduce el riesgo de integración**, al ejecutarse con frecuencia (idealmente a diario).
- 🛠️ **Facilita el diagnóstico y la corrección**, ya que los errores tienden a estar en el código recién incorporado.
- 📈 **Mejora la calidad** del producto final al evitar que builds defectuosas avancen en el flujo de pruebas.
- 📊 **Hace más fácil valorar el progreso** del proyecto.

---

## 🧠 Resumen

> La prueba de humo es una **verificación superficial pero estratégica**, que sirve como **control de calidad inicial**. Si una build falla esta prueba, no se debe continuar con pruebas más complejas hasta que se solucione el problema.







# 🧪 Tipos de Pruebas de Software

Esta nota resume cinco tipos clave de pruebas utilizadas en la calidad de software:

- [x] **Pruebas de Regresión**
- [x] **Pruebas de Validación (o Aceptación)**
- [x] **Pruebas de Humo**
- [x] **Pruebas de Sistema**
- [x] **Tipos de Pruebas de Sistema**

---

## 🔁 Pruebas de Regresión

> "¿Sigue funcionando lo que ya funcionaba?"

### 🎯 Objetivo
Verificar que **los cambios realizados no introduzcan errores** en funcionalidades previamente correctas.

### 🛠️ Características
- Re-ejecución de pruebas existentes tras una modificación del código.
- La batería de pruebas evoluciona con el sistema.
- Importante en proyectos con ciclos de cambios frecuentes.

---

## ✅ Pruebas de Validación (o Aceptación)

> "¿Construimos el producto correcto?"

### 🎯 Objetivo
Confirmar que el software **cumple con los requerimientos del cliente** y **satisface sus expectativas**.

### 📦 Cuándo se realizan
- Tras la construcción del sistema completo.
- Antes de la entrega final al usuario.

### 🧰 Características
- Se basan en los criterios de aceptación definidos en los requisitos.
- Caja negra.
- Foco en la perspectiva del usuario final.

---

## 🚬 Pruebas de Humo (Smoke Tests)

> "¿Es estable la build para seguir probando?"

### 🎯 Objetivo
Comprobar rápidamente que las **funcionalidades críticas del sistema funcionan correctamente** después de cada *build*.

### 🧪 Características
- Superficiales pero amplias.
- Detectan fallos graves tempranos.
- Automatizadas en entornos de integración continua.

---

## 🖥️ Pruebas de Sistema (System Tests)

> "¿Funciona el sistema completo, como un todo?"

### 🎯 Objetivo
Verificar que **todos los elementos del sistema interactúan adecuadamente** y que el sistema completo funciona según lo esperado.

### 🧰 Características
- Se ejecutan tras las pruebas de validación.
- Prueban el software en su **entorno real**, incluyendo:
  - Software
  - Hardware
  - Base de datos
  - Interfaces de red
  - Operadores humanos
- Son **pruebas de caja negra**.
- Simulan escenarios reales de uso.

---

### 🧩 Tipos de Pruebas de Sistema

| Tipo de prueba         | Descripción |
|------------------------|-------------|
| 🔄 **Recuperación**     | Se fuerza el fallo del sistema para verificar la capacidad de recuperación ante errores o fallas. |
| 🔐 **Seguridad**        | Evalúa vulnerabilidades, accesos no autorizados, y protección de datos sensibles. |
| 💣 **Estrés**           | Determina los límites del sistema bajo cargas extremas (usuarios simultáneos, solicitudes masivas, etc.). |
| 🚀 **Rendimiento**      | Mide velocidad, capacidad de respuesta y estabilidad bajo condiciones normales y pico. |
| 📦 **Despliegue**       | Verifica la correcta instalación y funcionamiento del sistema en los entornos reales de producción. |

---

## 🧠 Resumen Comparativo

| Tipo de prueba     | ¿Cuándo se hace?               | ¿Qué evalúa?                                      | Nivel de profundidad     |
|--------------------|--------------------------------|--------------------------------------------------|---------------------------|
| **Regresión**      | Después de cambios al código   | Que lo anterior siga funcionando                 | Medio                    |
| **Validación**     | Al finalizar el desarrollo     | Que cumple con los requerimientos del cliente    | Alto (caja negra)         |
| **Humo**           | Después de cada *build*        | Que lo esencial no esté roto                     | Bajo pero amplio           |
| **Sistema**        | Luego de validación            | El funcionamiento del sistema como un todo       | Alto, orientado al entorno |

---


