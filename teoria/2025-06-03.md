
# ğŸ§© Pruebas de Estructura de Control

> âš™ï¸ Son un subconjunto de las **pruebas de caja blanca** que se enfocan en verificar el **flujo de control interno** del software.

---

## ğŸ§  Â¿QuÃ© son?

Aunque el tÃ©rmino "pruebas de estructura de control" no estÃ¡ definido explÃ­citamente en todas las fuentes, se entiende como aquellas **pruebas internas que analizan la lÃ³gica de control del cÃ³digo**, tÃ­picas de la **prueba de caja blanca**.

---

## ğŸ” RelaciÃ³n con la Prueba de Caja Blanca

Las **pruebas de estructura de control**:
- Se basan en **"meterse dentro del cÃ³digo"** para diseÃ±ar casos de prueba.
- EvalÃºan decisiones, bucles, condiciones y bifurcaciones internas del programa.
- Se oponen a la prueba de caja negra, que evalÃºa solo la entrada y salida del sistema.

---

## ğŸ§± UbicaciÃ³n en el Proceso de Desarrollo

### ğŸ“ Modelo en V
- El **modelo en V** relaciona etapas de desarrollo con sus respectivas pruebas.
- Las pruebas de estructura de control se aplican en:
  - ğŸ”¸ **Pruebas unitarias**
  - ğŸ”¸ Fase de **construcciÃ³n** (codificaciÃ³n + pruebas)
- Su objetivo es validar la **base de la pirÃ¡mide de calidad** del software.

### ğŸ•“ Principio "Shift Left"
- Detectar errores **temprano = menor costo**.
- Las pruebas de estructura de control contribuyen a:
  - ğŸª› Corregir antes de producciÃ³n.
  - ğŸªœ Evitar acumulaciÃ³n de defectos.
  - ğŸ“‰ Reducir los costos segÃºn la **Curva de Boehm**.

---

## ğŸ”„ RelaciÃ³n con la IntegraciÃ³n de MÃ³dulos

### â¬†ï¸ IntegraciÃ³n Ascendente
- Se empieza por probar mÃ³dulos atÃ³micos de bajo nivel.
- Ventajas:
  - âœ”ï¸ Permite probar antes las **funciones de control**.
  - âœ”ï¸ Simplifica casos de prueba: **no requiere stubs** una vez que los mÃ³dulos bÃ¡sicos estÃ¡n listos.
  - âœ”ï¸ Facilita el anÃ¡lisis de **mÃ³dulos crÃ­ticos**, con alto control o complejidad.

---

## âœ… En resumen

Las **pruebas de estructura de control**:
- Son **pruebas de caja blanca** que verifican la lÃ³gica interna.
- Son clave en las **etapas tempranas** del desarrollo.
- Apoyan la estrategia de **"Shift Left"**.
- Mejoran la **calidad y mantenibilidad** del software.

> ğŸ§ª Se enfocan en asegurar que **cada camino de control y decisiÃ³n del cÃ³digo se comporta como se espera**.


# ğŸ§ª Pruebas de CondiciÃ³n, Flujo de Datos y Bucles

> Estas pruebas son distintas formas de **revisar el interior del programa**: el cÃ³digo. Son parte de las **pruebas de caja blanca**, donde miramos *cÃ³mo* funciona el software por dentro, no solo *quÃ© hace*.

Sirven para **detectar errores lÃ³gicos** que no se verÃ­an desde afuera, y elegimos cuÃ¡l usar dependiendo de:
- ğŸ¤¯ La complejidad del cÃ³digo
- ğŸ•’ El tiempo disponible
- ğŸ‘¥ Los recursos humanos que tenemos

---

## ğŸ§¾ Prueba de CondiciÃ³n

ğŸ¯ **Objetivo:** Verificar que cada condiciÃ³n lÃ³gica o regla del programa funcione por separado.

ğŸ’¡ **Ejemplo:**  
Si en un juego la regla es:  
```si tenÃ©s mÃ¡s de 10 puntos, ganÃ¡s```,  
esta prueba comprueba que esa condiciÃ³n se cumpla correctamente, sin importar el camino que se haya seguido.

ğŸ” Se enfoca en:
- Condiciones simples (`if`, `else`, `switch`)
- Evaluar cada posible resultado de una condiciÃ³n, de forma aislada

---

## ğŸ§¬ Prueba de Flujo de Datos

ğŸ¯ **Objetivo:** Seguir el recorrido de las **variables** en el cÃ³digo, desde que se **definen** hasta que se **usan**.

ğŸ’¡ **Ejemplo:**  
Como seguir el azÃºcar desde que la sacÃ¡s de la alacena (la definÃ­s) hasta que la usÃ¡s en la torta (la utilizÃ¡s en una operaciÃ³n).

ğŸ” Se enfoca en:
- Variables mal inicializadas o sin usar
- Uso de datos sin definir
- Rutas de cÃ³digo que no actualizan correctamente los valores

---

## ğŸ” Prueba de Bucles

ğŸ¯ **Objetivo:** Evaluar cÃ³mo se comportan los **bucles** (estructuras repetitivas) en diferentes escenarios.

ğŸ’¡ **Ejemplo:**  
Como probar saltar la soga:
- ğŸª‚ Una sola vez
- ğŸ” Varias veces
- ğŸ›‘ Hasta el lÃ­mite

ğŸ” Se enfoca en:
- EjecuciÃ³n **cero veces** (Â¿el bucle puede no ejecutarse?)
- EjecuciÃ³n **una vez**
- EjecuciÃ³n **varias veces**
- Casos **lÃ­mite o extremos** (por ejemplo, con el mÃ¡ximo de iteraciones)

---

## âœ… En resumen

| Tipo de prueba        | Â¿QuÃ© revisa?                             | Â¿Para quÃ© sirve?                             |
|-----------------------|------------------------------------------|----------------------------------------------|
| ğŸ§¾ CondiciÃ³n          | Las **reglas** o decisiones del cÃ³digo   | Ver que cada condiciÃ³n funcione correctamente|
| ğŸ§¬ Flujo de datos     | El **uso de variables** en el tiempo     | Detectar errores de inicializaciÃ³n y uso     |
| ğŸ” Bucles             | Las **estructuras repetitivas**          | Ver que se comporten bien en todos los casos |

> ğŸ§  Todas son esenciales en pruebas de caja blanca para asegurar que el cÃ³digo **funciona como se espera internamente**.





# ğŸ§± Pruebas de Caja Negra (o Pruebas de Comportamiento)

> ğŸ“¦ ImaginÃ¡ que tenÃ©s un **juguete nuevo** y no sabÃ©s quÃ© tiene adentro. Solo podÃ©s probarlo **apretando botones** y viendo cÃ³mo responde.  
Eso es una **prueba de caja negra**: no importa cÃ³mo funciona por dentro, solo te importa **lo que hace**.

---

## ğŸ¯ Â¿QuÃ© es una Prueba de Caja Negra?

- Es un tipo de prueba en el que **no se mira el cÃ³digo fuente**.
- Se enfoca exclusivamente en la **entrada** y la **salida esperada** del software.
- Busca confirmar que el sistema **cumple con los requisitos funcionales**.

ğŸ§ª **Ejemplo:**  
IngresÃ¡s un nÃºmero en una calculadora. No te importa cÃ³mo hace la cuenta internamente, solo querÃ©s saber si **el resultado es correcto**.

---

## ğŸ› ï¸ CaracterÃ­sticas Principales

- âœ… EvalÃºa si el software **hace lo que debe hacer**.
- ğŸš« No considera el diseÃ±o interno ni la lÃ³gica del cÃ³digo.
- ğŸ§‘â€ğŸ’» Se realiza sobre la **interfaz del sistema** (inputs/outputs).
- ğŸ¤ Complementa a las pruebas de caja blanca (Â¡no la reemplaza!).
- ğŸ”„ A medida que el software madura, **se incrementan las pruebas de caja negra**.

---

## ğŸ“ TÃ©cnicas para diseÃ±ar pruebas de Caja Negra

### ğŸ”³ ParticiÃ³n Equivalente
- Divide los datos de entrada en **grupos vÃ¡lidos e invÃ¡lidos**.
- Se prueba un caso representativo por grupo.

> âœ¨ Ejemplo: Si el sistema acepta edades entre 18 y 65, probÃ¡s con:
> - Un valor dentro del rango (âœ…)
> - Uno menor a 18 (âŒ)
> - Uno mayor a 65 (âŒ)

---

### ğŸ“ AnÃ¡lisis de Valores LÃ­mite
- Se prueba con valores **en los bordes del rango permitido**.

> âœ¨ Ejemplo:  
> Si una funciÃ³n acepta valores de 1 a 100:
> - ProbÃ¡s con 1 (mÃ­nimo aceptado)  
> - ProbÃ¡s con 100 (mÃ¡ximo aceptado)  
> - ProbÃ¡s con 0 y 101 (valores lÃ­mite no vÃ¡lidos)

---

### ğŸ” Prueba de ComparaciÃ³n
- Se ejecutan **mÃºltiples versiones del software** con los mismos datos para ver si los resultados coinciden.

---

### ğŸ§® MÃ©todos basados en Grafos
- Se modela el comportamiento del sistema como un **grafo de estados y transiciones**, probando distintos caminos posibles.

---

## ğŸš— Â¿Caja Blanca vs. Caja Negra?

| Tipo de Prueba      | Â¿QuÃ© se mira?              | Â¿CÃ³mo se hace?                          |
|---------------------|-----------------------------|------------------------------------------|
| âšª Caja Blanca       | El **interior del cÃ³digo**  | Revisando lÃ³gica, bucles, condiciones    |
| âš« Caja Negra        | El **comportamiento externo**| Usando entradas/salidas esperadas        |

---

## âœ… En resumen

> Si la **caja blanca** es como revisar el motor de un auto...  
> la **caja negra** es como **subirte, manejarlo y ver si funciona bien**.

Ambas pruebas son **complementarias** y fundamentales para garantizar la **calidad del software** desde diferentes Ã¡ngulos.  




# âš« MÃ©todos de Pruebas de Caja Negra

Las **pruebas de caja negra** se centran en verificar si el software cumple con sus **requisitos funcionales**, sin mirar el cÃ³digo. Se ejecutan desde la **interfaz** del sistema y se complementan con las pruebas de caja blanca.

## ğŸ§ª Objetivo general

- Evaluar si el sistema **responde correctamente a distintas entradas**.
- Detectar errores como:
  - Funciones incorrectas o faltantes.
  - Problemas de interfaz.
  - Errores en estructuras de datos externas o bases de datos.
  - DesvÃ­os respecto a requisitos.

---

## ğŸ” MÃ©todos para diseÃ±ar casos de prueba de caja negra

### 1. ğŸ—ºï¸ **MÃ©todos Basados en Grafos**

> **Analizan la estructura del sistema como un grafo (nodos + conexiones)**.

- Se visualiza el software como un **mapa conceptual**, donde:
  - Los **nodos** representan entidades, procesos, pantallas, etc.
  - Las **aristas** representan la transiciÃ³n o comunicaciÃ³n entre ellos.
- Permite:
  - DiseÃ±ar rutas que simulan distintos recorridos de uso.
  - Detectar fallos en la lÃ³gica de navegaciÃ³n o flujo de trabajo.

ğŸ“Œ *Ideal para sistemas complejos o distribuidos.*

---

### 2. ğŸ¬ **ParticiÃ³n Equivalente**

> Divide el dominio de entrada en **clases que se comportan de forma similar**.

ğŸ§  Idea clave: **Si una entrada de una clase funciona bien, se asume que las demÃ¡s tambiÃ©n.**

- Tipos de clases:
  - **VÃ¡lidas**: deben producir una salida correcta.
  - **InvÃ¡lidas**: deben ser rechazadas o generar error controlado.
  
ğŸ“Œ *Reduce la cantidad de pruebas sin perder cobertura.*

ğŸ§¾ **Ejemplo**:
- Entrada vÃ¡lida: monedas entre $1 y $10.
- Entrada invÃ¡lida: billetes, monedas rotas, etc.
- Se prueba **una entrada representativa por clase**.

---

### 3. ğŸ“ **AnÃ¡lisis de Valores LÃ­mite**

> Se enfoca en los **bordes del dominio vÃ¡lido**: donde suelen aparecer errores.

- Se prueban:
  - Los **lÃ­mites inferiores y superiores** vÃ¡lidos.
  - Justo **por debajo y por encima** de esos lÃ­mites.

ğŸ§¾ **Ejemplo**:
- Rango vÃ¡lido: 1 a 100.
- Casos a probar: `0`, `1`, `2`, `99`, `100`, `101`.

ğŸ“Œ *Complementa la particiÃ³n equivalente con pruebas mÃ¡s precisas.*

---

### 4. ğŸ§ª **Prueba de ComparaciÃ³n**

> Se ejecutan **dos o mÃ¡s versiones** del software con los mismos datos para **comparar resultados**.

ğŸ¯ Ãštil cuando:
- Se estÃ¡ migrando de versiÃ³n.
- Existen mÃºltiples implementaciones (ej. paralelas o por diferentes proveedores).

ğŸ“Œ *Ayuda a detectar desviaciones funcionales crÃ­ticas.*

---

### 5. ğŸ§® **Prueba de la Tabla Ortogonal**

> DiseÃ±ada para manejar **muchas combinaciones posibles de entradas** sin probarlas todas.

- Usa principios matemÃ¡ticos (diseÃ±o ortogonal) para seleccionar un **conjunto mÃ­nimo de combinaciones representativas**.
- Maximiza la cobertura con **menos casos de prueba**.

ğŸ§¾ **Ejemplo**:
- 4 parÃ¡metros, cada uno con 3 posibles valores = 81 combinaciones.
- Tabla ortogonal puede reducir eso a 9 pruebas clave sin perder efectividad.

ğŸ“Œ *Ideal para configuraciones de entrada mÃºltiples o pruebas de compatibilidad.*

---

## ğŸ“Œ En resumen

| MÃ©todo                      | Â¿Para quÃ© sirve?                              | Ejemplo simple                        |
|----------------------------|-----------------------------------------------|---------------------------------------|
| ğŸ”³ ParticiÃ³n Equivalente    | Probar por grupos de entradas similares       | Monedas vÃ¡lidas / invÃ¡lidas           |
| ğŸ“ AnÃ¡lisis de LÃ­mites      | Ver quÃ© pasa en los bordes del rango          | $1, $10, $0.99, $10.01                |
| ğŸ—ºï¸ Basado en Grafos         | Explorar rutas posibles del sistema           | MenÃº â†’ SubmenÃº â†’ AcciÃ³n               |
| ğŸ§ª ComparaciÃ³n               | Ver si varias versiones dan el mismo resultado| Comparar dos calculadoras             |
| ğŸ§® Tabla Ortogonal           | Probar muchas combinaciones con pocos casos   | ParÃ¡metros de configuraciÃ³n mÃºltiples |

---

## âœ… ConclusiÃ³n

> Las pruebas de caja negra permiten verificar el **comportamiento funcional del sistema sin conocer su cÃ³digo fuente**.  
> Son una herramienta **clave para garantizar la calidad del software**, especialmente desde el punto de vista del usuario.












# ğŸ§ª ComparaciÃ³n entre Pruebas de Caja Blanca y Caja Negra

Las pruebas de software son fundamentales para garantizar la calidad del producto. Entre las mÃ¡s importantes se encuentran las **pruebas de caja blanca** y las **pruebas de caja negra**. A continuaciÃ³n, exploramos sus diferencias, objetivos y tÃ©cnicas, asÃ­ como cÃ³mo se complementan entre sÃ­.

---

## ğŸ” Â¿QuÃ© son las pruebas de caja blanca?

ImaginÃ¡ que tenÃ©s un coche y abrÃ­s el capÃ³ para ver cÃ³mo estÃ¡ conectado el motor, los cables y las bujÃ­as. Esa es la idea detrÃ¡s de las pruebas de caja blanca.

### ğŸ¯ CaracterÃ­sticas principales

- **ğŸ”§ Perspectiva interna:** Se examina la lÃ³gica y estructura interna del cÃ³digo fuente.
- **ğŸ§  Requiere conocimientos tÃ©cnicos:** El probador debe tener acceso al cÃ³digo y entender su lÃ³gica, estructuras de datos y flujo de control.
- **âœ… Objetivo:** Verificar que todos los **caminos lÃ³gicos** se ejecutan al menos una vez, y que el estado del programa es correcto en puntos clave.
- **ğŸ“ AplicaciÃ³n tÃ­pica:** Pruebas unitarias y, a veces, de integraciÃ³n a bajo nivel.

### ğŸ› ï¸ TÃ©cnicas comunes

- **Prueba del camino bÃ¡sico:** Asegura que todos los caminos independientes del programa se ejecuten.
- **Prueba de condiciones:** EvalÃºa todas las combinaciones lÃ³gicas de condiciones.
- **Prueba de flujo de datos:** Analiza el uso de variables (dÃ³nde se definen y dÃ³nde se usan).
- **Prueba de bucles:** EvalÃºa bucles con diferentes cantidades de iteraciones (cero, una, muchas).

---

## ğŸ§­ Â¿QuÃ© son las pruebas de caja negra?

Ahora imaginÃ¡ que usÃ¡s el coche sin abrir el capÃ³: encendÃ©s el motor, probÃ¡s si arranca, si dobla, si frenaâ€¦ asÃ­ funcionan las pruebas de caja negra.

### ğŸ¯ CaracterÃ­sticas principales

- **ğŸ”’ Perspectiva externa:** El sistema se trata como una caja cerrada. Se evalÃºan entradas y salidas sin conocer el cÃ³digo interno.
- **ğŸ‘¥ No requiere conocimiento del cÃ³digo:** Se basa en los requisitos funcionales del sistema.
- **âœ… Objetivo:** Verificar que el software **cumple sus requisitos funcionales**. Se observa cÃ³mo responde ante entradas vÃ¡lidas e invÃ¡lidas.
- **ğŸ“ AplicaciÃ³n tÃ­pica:** Pruebas de validaciÃ³n, pruebas de sistema, integraciÃ³n de alto nivel.

### ğŸ› ï¸ TÃ©cnicas comunes

- **ParticiÃ³n de equivalencia:** Agrupa entradas similares que deberÃ­an comportarse igual.
- **AnÃ¡lisis de valores lÃ­mites:** EvalÃºa entradas en los extremos de los rangos permitidos.
- **MÃ©todos basados en grafos:** Representan la interacciÃ³n entre componentes o flujos.
- **Prueba de comparaciÃ³n:** EvalÃºa si mÃºltiples implementaciones generan los mismos resultados.
- **Tablas ortogonales:** Selecciona combinaciones representativas en dominios de entrada complejos.

---

## ğŸ†š Tabla comparativa

| CaracterÃ­stica              | ğŸ§ª Caja Blanca                        | ğŸ­ Caja Negra                               |
|----------------------------|--------------------------------------|---------------------------------------------|
| Perspectiva                | Interna (estructura del cÃ³digo)      | Externa (funcionalidad observable)          |
| Conocimiento del cÃ³digo    | Requiere                             | No requiere                                 |
| QuÃ© se prueba              | LÃ³gica, flujo, condiciones, bucles   | Entradas, salidas, comportamiento esperado  |
| Nivel de aplicaciÃ³n        | Bajo (unidad, integraciÃ³n interna)   | Alto (sistema, validaciÃ³n, interfaz)        |
| QuiÃ©n la realiza           | Desarrolladores                      | Testers, QA, usuarios finales               |
| Errores que detecta        | LÃ³gicos, estructurales, rutas no cubiertas | Requisitos no cumplidos, respuestas errÃ³neas, fallos en interfaz |
| TÃ©cnicas tÃ­picas           | Camino bÃ¡sico, bucles, flujo de datos| ParticiÃ³n, lÃ­mites, comparaciÃ³n, grafos     |

---

## ğŸ¤ Â¿Se usan juntas?

Â¡SÃ­! Las pruebas de caja blanca y negra no son excluyentes, sino **complementarias**:

- ğŸ”„ **Caja blanca** detecta errores de **implementaciÃ³n**.
- ğŸ¯ **Caja negra** detecta errores de **especificaciÃ³n** y fallas de comportamiento.

> ğŸ” Mientras la prueba de caja blanca asegura que el motor funciona correctamente, la prueba de caja negra verifica que el coche haga lo que el usuario espera.

---
## ğŸ§  ConclusiÃ³n

Combinar ambos tipos de pruebas permite una visiÃ³n integral del sistema:

- Asegura la **calidad interna del cÃ³digo**.
- Valida el **cumplimiento de los requisitos funcionales**.
- Ofrece **mayor cobertura de errores** en todo el ciclo de vida del software.







# âœ… VerificaciÃ³n vs ValidaciÃ³n en IngenierÃ­a de Software

En el desarrollo de software, asegurar la calidad del producto implica mÃ¡s que simplemente probar el cÃ³digo. Esto se logra mediante un proceso conocido como **VerificaciÃ³n y ValidaciÃ³n (V&V)**, del cual las pruebas de software son solo una parte.

---

## ğŸ› ï¸ Â¿QuÃ© es la VerificaciÃ³n?

> **Pregunta clave:** *Â¿Construimos el producto correctamente?*

### ğŸ“Œ DefiniciÃ³n
La **verificaciÃ³n** es el proceso que garantiza que el software **cumple con sus especificaciones tÃ©cnicas**. Se centra en asegurar que cada componente del sistema funcione conforme a lo diseÃ±ado.

### ğŸ” Enfoque
- Verifica la **exactitud tÃ©cnica de la implementaciÃ³n**.
- Implica revisar si el **cÃ³digo y los procesos internos** cumplen lo esperado.

### ğŸ§ª Ejemplos de actividades
- RevisiÃ³n de cÃ³digo fuente
- AnÃ¡lisis de complejidad
- Pruebas unitarias
- RevisiÃ³n de documentaciÃ³n tÃ©cnica
- AuditorÃ­as de calidad

---

## ğŸ¯ Â¿QuÃ© es la ValidaciÃ³n?

> **Pregunta clave:** *Â¿Construimos el producto correcto?*

### ğŸ“Œ DefiniciÃ³n
La **validaciÃ³n** asegura que el producto **cumple con los requerimientos del usuario o cliente final**. Se trata de confirmar que lo desarrollado realmente resuelve el problema para el cual fue creado.

### ğŸ” Enfoque
- Se centra en el **comportamiento externo y funcional** del sistema.
- EvalÃºa si el software **satisface las necesidades reales del usuario**.

### ğŸ§ª Ejemplos de actividades
- Pruebas de aceptaciÃ³n del usuario
- Pruebas de sistema
- Demostraciones al cliente
- Simulaciones y prototipos funcionales

---

## ğŸ”„ Diferencias clave

| Aspecto                  | ğŸ”§ VerificaciÃ³n                         | ğŸ‘¥ ValidaciÃ³n                                |
|--------------------------|----------------------------------------|---------------------------------------------|
| Enfoque principal        | TÃ©cnicamente correcto                  | Funcionalmente correcto                      |
| Pregunta que responde    | Â¿Lo hicimos bien?                      | Â¿Hicimos lo que el cliente querÃ­a?          |
| Perspectiva              | Interna (desarrollo y calidad)         | Externa (usuario final)                     |
| Acceso al cÃ³digo         | SÃ­                                     | No necesariamente                           |
| Ejemplos tÃ­picos         | Revisiones, anÃ¡lisis estÃ¡tico, pruebas unitarias | Pruebas de aceptaciÃ³n, validaciÃ³n de requisitos |
| Momento de aplicaciÃ³n    | Durante el desarrollo                  | Al final del desarrollo / antes del despliegue |

---

## ğŸ’¬ MetÃ¡fora para recordar

> ğŸ—ï¸ *VerificaciÃ³n es como revisar si construimos correctamente cada ladrillo del edificio (estructura tÃ©cnica). ValidaciÃ³n es comprobar si ese edificio es lo que el cliente querÃ­a: con balcÃ³n, con luz natural, y en el barrio correcto.* ğŸ§â€â™‚ï¸ğŸ™ï¸

---

## ğŸ” V&V en el ciclo de vida moderno

En prÃ¡cticas modernas como **DevOps**, **IntegraciÃ³n Continua (CI)** y **Entrega Continua (CD)**:

- V&V no es un paso final, sino una actividad **continua**.
- Las herramientas automÃ¡ticas permiten verificar y validar de forma constante.
- Se integran prÃ¡cticas como:
  - **Tests automÃ¡ticos en cada commit**
  - **SimulaciÃ³n en entornos controlados**
  - **Feedback temprano del usuario**

---

## ğŸ§  ConclusiÃ³n

- **VerificaciÃ³n**: Garantiza que el producto estÃ¡ bien construido segÃºn lo especificado.
- **ValidaciÃ³n**: Asegura que el producto es Ãºtil y adecuado para el usuario.

Ambos enfoques son **complementarios** y necesarios para lograr software de alta calidad.

> ğŸ“Œ **No alcanza con que funcione; tiene que funcionar para lo que fue pensado.**





# ğŸ§ª VerificaciÃ³n y ValidaciÃ³n (V&V) + PirÃ¡mide de Pruebas

La **VerificaciÃ³n y ValidaciÃ³n (V&V)** es un conjunto de actividades esenciales en la ingenierÃ­a de software para garantizar la calidad del producto. Las **pruebas de software** son parte fundamental de este proceso.

---

## âœ… Diferencia entre VerificaciÃ³n y ValidaciÃ³n

| Concepto      | VerificaciÃ³n                                                | ValidaciÃ³n                                                   |
|---------------|-------------------------------------------------------------|--------------------------------------------------------------|
| Â¿QuÃ© pregunta responde? | **Â¿Construimos el producto correctamente?**         | **Â¿Construimos el producto correcto?**                      |
| Enfoque       | Exactitud tÃ©cnica de la implementaciÃ³n                      | Conformidad con los requisitos del cliente                   |
| Actividades   | RevisiÃ³n de cÃ³digo, anÃ¡lisis estÃ¡tico, pruebas unitarias... | Pruebas de aceptaciÃ³n, validaciÃ³n de funcionalidades visibles |
| Tipo de pruebas | MÃ¡s orientado a **caja blanca**                            | MÃ¡s orientado a **caja negra**                              |
| Nivel         | Interno al desarrollo                                        | Orientado al cliente/usuario final                          |

---

## ğŸ§± PirÃ¡mide de Pruebas y su RelaciÃ³n con el Modelo en V

La **pirÃ¡mide de pruebas** representa la jerarquÃ­a ideal en la cantidad y tipo de pruebas que se deben realizar:

```
    ğŸ”º Pruebas de AceptaciÃ³n (ValidaciÃ³n)
   ğŸ”ºğŸ”º Pruebas de Sistema
  ğŸ”ºğŸ”ºğŸ”º Pruebas de IntegraciÃ³n
 ğŸ”ºğŸ”ºğŸ”ºğŸ”º Pruebas Unitarias (VerificaciÃ³n)
```

Estas pruebas se relacionan con las fases del **Modelo en V**:

---

### 1. ğŸ§ª Pruebas Unitarias (Unit Tests)
- **Fase del Modelo en V**: GeneraciÃ³n de cÃ³digo
- **DescripciÃ³n**: Prueban funciones/mÃ³dulos individuales.
- **Tipo**: Caja blanca
- **Responsable**: Desarrollador
- **Objetivo**: Validar que cada componente funcione por sÃ­ solo.

---

### 2. ğŸ”— Pruebas de IntegraciÃ³n
- **Fase del Modelo en V**: DiseÃ±o de componentes
- **DescripciÃ³n**: Prueban la interacciÃ³n entre mÃ³dulos.
- **Tipo**: Caja negra (principalmente) y caja blanca (complementariamente)
- **Estrategias**:
  - IntegraciÃ³n descendente (top-down)
  - IntegraciÃ³n ascendente (bottom-up)

---

### 3. ğŸ–¥ï¸ Pruebas de Sistema
- **Fase del Modelo en V**: DiseÃ±o de la arquitectura
- **DescripciÃ³n**: Se prueba el sistema como un todo junto con otros elementos (hardware, redes, etc.)
- **Tipo**: Caja negra
- **Ejemplos**: Pruebas de rendimiento, estrÃ©s, seguridad, recuperaciÃ³n, etc.

---

### 4. ğŸ‘¥ Pruebas de AceptaciÃ³n / ValidaciÃ³n
- **Fase del Modelo en V**: Modelado de requerimientos
- **DescripciÃ³n**: EvalÃºan si el sistema cumple con las necesidades del cliente.
- **Tipo**: Caja negra
- **Responsable**: Cliente/usuario final
- **Objetivo**: Confirmar que se construyÃ³ el producto adecuado.

---

## ğŸ“ˆ Importancia de Probar Temprano

- La **curva de Boehm** muestra que **los errores son mÃ¡s costosos cuanto mÃ¡s tarde se detectan**.
- La estrategia de la pirÃ¡mide impulsa una **calidad desde el inicio**, con Ã©nfasis en pruebas automÃ¡ticas y frecuentes.
- En metodologÃ­as modernas como **CI/CD o DevOps**, V&V se realiza **continuamente** durante todo el ciclo de vida.

---

## ğŸ”„ RelaciÃ³n con V&V

- La pirÃ¡mide se integra dentro del enfoque global de **VerificaciÃ³n y ValidaciÃ³n**:
  - **VerificaciÃ³n**: Â¿Lo hicimos bien? (foco tÃ©cnico)
  - **ValidaciÃ³n**: Â¿Hicimos lo que el cliente querÃ­a? (foco funcional)

---

## ğŸ“Œ ConclusiÃ³n

La aplicaciÃ³n adecuada de la pirÃ¡mide de pruebas y el modelo en V asegura un proceso de desarrollo mÃ¡s eficiente, menos costoso y centrado en la calidad. **Probar pronto, probar con frecuencia y probar bien** es clave para el Ã©xito del software.



# ğŸ§© Pruebas de IntegraciÃ³n

Las **pruebas de integraciÃ³n** son un nivel crucial en la jerarquÃ­a de la **pirÃ¡mide de pruebas** y del ciclo de vida del desarrollo de software. Su objetivo principal es **verificar cÃ³mo funcionan los diferentes mÃ³dulos o componentes del software cuando se combinan**.

---

## ğŸ¯ PropÃ³sito y Enfoque

- Se ejecutan **despuÃ©s de las pruebas unitarias**, cuando los componentes individuales ya fueron verificados.
- Abordan el **problema de la conexiÃ³n entre mÃ³dulos**, es decir, asegurar que funcionen correctamente en conjunto.
- Se centran en:
  - El **diseÃ±o de la arquitectura del software**.
  - La **verificaciÃ³n de interfaces** y la correcta construcciÃ³n de programas.

---

## ğŸ§ª TÃ©cnicas de Prueba Utilizadas

- **Caja negra**: Enfocadas en entradas/salidas, sin considerar la lÃ³gica interna.
- **Caja blanca**: A veces se usan para examinar rutas especÃ­ficas del cÃ³digo y lograr mayor cobertura.

---

## ğŸ”„ Estrategias de Prueba de IntegraciÃ³n

Evitar la integraciÃ³n **no incremental** (integrar todo de golpe), ya que dificulta el diagnÃ³stico de errores.

### âœ… Se prefiere la integraciÃ³n **incremental**, que permite:

- Aislar y corregir errores mÃ¡s fÃ¡cilmente.
- Probar interfaces de manera controlada.
- Mantener una construcciÃ³n sistemÃ¡tica del software.

---

### ğŸ”½ IntegraciÃ³n Descendente (Top-Down)

- Se comienza por el **mÃ³dulo principal**, agregando luego los subordinados.
- Dos variantes: **por profundidad** o **por anchura**.
- Se utilizan **stubs** (simulaciones de mÃ³dulos aÃºn no implementados).

**Ventajas**:
- Permite probar las funciones de control centrales desde el inicio.

**Desventajas**:
- Los stubs pueden dificultar la identificaciÃ³n de errores especÃ­ficos.
- Se pierde precisiÃ³n en la correlaciÃ³n entre pruebas y errores.

---

### ğŸ”¼ IntegraciÃ³n Ascendente (Bottom-Up)

- Se comienza desde los **mÃ³dulos mÃ¡s bajos** (atÃ³micos) y se va hacia arriba.
- No requiere stubs, ya que los mÃ³dulos inferiores estÃ¡n ya probados.

**Ventajas**:
- Facilita el diseÃ±o de casos de prueba.
- Mejora el control sobre el proceso de integraciÃ³n.

**Desventajas**:
- El sistema completo no estÃ¡ disponible hasta que se ensamblan los niveles superiores.

---

## ğŸ” RelaciÃ³n con la IntegraciÃ³n Continua

- La **integraciÃ³n continua (CI)** es una prÃ¡ctica Ã¡gil que fomenta integrar cÃ³digo frecuentemente (idealmente, a diario).
- Cada integraciÃ³n se valida automÃ¡ticamente mediante una **build automatizada** que incluye pruebas automatizadas (unitarias e integraciÃ³n).
- Objetivo: **detectar y resolver errores lo antes posible**, reduciendo el costo de las fallas detectadas tardÃ­amente.

---

## ğŸ§  Resumen

> Las pruebas de integraciÃ³n aseguran que los **mÃ³dulos funcionan bien en conjunto**, mientras que la integraciÃ³n incremental y continua permite detectar errores en las interfaces **temprano y frecuentemente**, lo cual es esencial para una arquitectura de software robusta y escalable.







# ğŸš¬ Prueba de Humo (Smoke Test)

La **prueba de humo** es una prueba inicial que se ejecuta **despuÃ©s de compilar una build del software**, con el objetivo de **verificar que las funcionalidades bÃ¡sicas y crÃ­ticas funcionen correctamente**.

---

## ğŸ¯ PropÃ³sito Principal

- Detectar de forma temprana si los elementos mÃ¡s importantes del sistema **no funcionan**.
- Verificar aspectos fundamentales como:
  - Que la aplicaciÃ³n **se inicie correctamente**.
  - Que las **conexiones y accesos** (como el login) funcionen.
  - Que los **botones y funciones clave** respondan como se espera.

---

## ğŸ§­ Alcance

- Debe **ejercitar todo el sistema de extremo a extremo**, aunque de forma superficial.
- No busca ser exhaustiva, sino **exponer errores graves rÃ¡pidamente**.
- Se centra en probar lo mÃ¡s propenso a fallar:
  - Funciones crÃ­ticas.
  - Procesos esenciales.
- Permite suponer que, si pasa la prueba de humo, la build es **lo suficientemente estable para pruebas mÃ¡s profundas**.

---

## ğŸ§ª Casos de Prueba

1. Identificar las funcionalidades **bÃ¡sicas y crÃ­ticas** que debe cumplir el producto.
2. DiseÃ±ar casos de prueba para esas funcionalidades.
3. Ejecutar esta suite de pruebas **con cada nueva build**.
4. Estas pruebas pueden incluir:
   - Pruebas funcionales.
   - Pruebas unitarias.
   - Pruebas de sistema.

---

## ğŸ” En IntegraciÃ³n Continua (CI)

- Las pruebas de humo **automatizadas** se ejecutan **automÃ¡ticamente** con cada nueva build.
- ActÃºan como **filtro rÃ¡pido** para asegurar que los desarrollos recientes no rompan las funciones esenciales.

---

## âœ… Ventajas

- ğŸ” **DetecciÃ³n temprana de errores**, especialmente en entornos de integraciÃ³n continua.
- ğŸ§© **Reduce el riesgo de integraciÃ³n**, al ejecutarse con frecuencia (idealmente a diario).
- ğŸ› ï¸ **Facilita el diagnÃ³stico y la correcciÃ³n**, ya que los errores tienden a estar en el cÃ³digo reciÃ©n incorporado.
- ğŸ“ˆ **Mejora la calidad** del producto final al evitar que builds defectuosas avancen en el flujo de pruebas.
- ğŸ“Š **Hace mÃ¡s fÃ¡cil valorar el progreso** del proyecto.

---

## ğŸ§  Resumen

> La prueba de humo es una **verificaciÃ³n superficial pero estratÃ©gica**, que sirve como **control de calidad inicial**. Si una build falla esta prueba, no se debe continuar con pruebas mÃ¡s complejas hasta que se solucione el problema.







# ğŸ§ª Tipos de Pruebas de Software

Esta nota resume cinco tipos clave de pruebas utilizadas en la calidad de software:

- [x] **Pruebas de RegresiÃ³n**
- [x] **Pruebas de ValidaciÃ³n (o AceptaciÃ³n)**
- [x] **Pruebas de Humo**
- [x] **Pruebas de Sistema**
- [x] **Tipos de Pruebas de Sistema**

---

## ğŸ” Pruebas de RegresiÃ³n

> "Â¿Sigue funcionando lo que ya funcionaba?"

### ğŸ¯ Objetivo
Verificar que **los cambios realizados no introduzcan errores** en funcionalidades previamente correctas.

### ğŸ› ï¸ CaracterÃ­sticas
- Re-ejecuciÃ³n de pruebas existentes tras una modificaciÃ³n del cÃ³digo.
- La baterÃ­a de pruebas evoluciona con el sistema.
- Importante en proyectos con ciclos de cambios frecuentes.

---

## âœ… Pruebas de ValidaciÃ³n (o AceptaciÃ³n)

> "Â¿Construimos el producto correcto?"

### ğŸ¯ Objetivo
Confirmar que el software **cumple con los requerimientos del cliente** y **satisface sus expectativas**.

### ğŸ“¦ CuÃ¡ndo se realizan
- Tras la construcciÃ³n del sistema completo.
- Antes de la entrega final al usuario.

### ğŸ§° CaracterÃ­sticas
- Se basan en los criterios de aceptaciÃ³n definidos en los requisitos.
- Caja negra.
- Foco en la perspectiva del usuario final.

---

## ğŸš¬ Pruebas de Humo (Smoke Tests)

> "Â¿Es estable la build para seguir probando?"

### ğŸ¯ Objetivo
Comprobar rÃ¡pidamente que las **funcionalidades crÃ­ticas del sistema funcionan correctamente** despuÃ©s de cada *build*.

### ğŸ§ª CaracterÃ­sticas
- Superficiales pero amplias.
- Detectan fallos graves tempranos.
- Automatizadas en entornos de integraciÃ³n continua.

---

## ğŸ–¥ï¸ Pruebas de Sistema (System Tests)

> "Â¿Funciona el sistema completo, como un todo?"

### ğŸ¯ Objetivo
Verificar que **todos los elementos del sistema interactÃºan adecuadamente** y que el sistema completo funciona segÃºn lo esperado.

### ğŸ§° CaracterÃ­sticas
- Se ejecutan tras las pruebas de validaciÃ³n.
- Prueban el software en su **entorno real**, incluyendo:
  - Software
  - Hardware
  - Base de datos
  - Interfaces de red
  - Operadores humanos
- Son **pruebas de caja negra**.
- Simulan escenarios reales de uso.

---

### ğŸ§© Tipos de Pruebas de Sistema

| Tipo de prueba         | DescripciÃ³n |
|------------------------|-------------|
| ğŸ”„ **RecuperaciÃ³n**     | Se fuerza el fallo del sistema para verificar la capacidad de recuperaciÃ³n ante errores o fallas. |
| ğŸ” **Seguridad**        | EvalÃºa vulnerabilidades, accesos no autorizados, y protecciÃ³n de datos sensibles. |
| ğŸ’£ **EstrÃ©s**           | Determina los lÃ­mites del sistema bajo cargas extremas (usuarios simultÃ¡neos, solicitudes masivas, etc.). |
| ğŸš€ **Rendimiento**      | Mide velocidad, capacidad de respuesta y estabilidad bajo condiciones normales y pico. |
| ğŸ“¦ **Despliegue**       | Verifica la correcta instalaciÃ³n y funcionamiento del sistema en los entornos reales de producciÃ³n. |

---

## ğŸ§  Resumen Comparativo

| Tipo de prueba     | Â¿CuÃ¡ndo se hace?               | Â¿QuÃ© evalÃºa?                                      | Nivel de profundidad     |
|--------------------|--------------------------------|--------------------------------------------------|---------------------------|
| **RegresiÃ³n**      | DespuÃ©s de cambios al cÃ³digo   | Que lo anterior siga funcionando                 | Medio                    |
| **ValidaciÃ³n**     | Al finalizar el desarrollo     | Que cumple con los requerimientos del cliente    | Alto (caja negra)         |
| **Humo**           | DespuÃ©s de cada *build*        | Que lo esencial no estÃ© roto                     | Bajo pero amplio           |
| **Sistema**        | Luego de validaciÃ³n            | El funcionamiento del sistema como un todo       | Alto, orientado al entorno |

---


