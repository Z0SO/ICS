


### **Década de 2000's: Agilidad y Valor**  
*(El auge de los métodos ágiles y sus desafíos)*  

---

### **1. Introducción**  
**Contexto**:  
- Los modelos tradicionales (como **Cascada**) eran lentos para entornos cambiantes.  
- **Nuevo paradigma**: Agilidad = **Velocidad + Adaptabilidad**, pero con riesgos en *calidad* y *mantenimiento*.  

**Problema clave**:  
- Malinterpretación de la agilidad → "**Hacer rápido sin planear**" generó deuda técnica y costos ocultos.  

---
### **2. Agilidad**  
#### **2.1 Movimiento Ágil**  
- **Manifiesto Ágil (2001)**:  
  ```  
  1. Individuos e interacciones > Procesos y herramientas  
  2. Software funcionando > Documentación extensiva  
  3. Colaboración con el cliente > Negociación contractual  
  4. Responder al cambio > Seguir un plan  
  ```  
- **Errores comunes**:  
  - Pensar que "ágil" = **improvisar** (ej.: requisitos ambiguos).  
  - Subestimar el **mantenimiento** (60-80% del esfuerzo total).  

**Lección**:  
> "La agilidad no es falta de disciplina, sino **flexibilidad inteligente**".  


#### **2.2 Agilidad vs. XP (eXtreme Programming)**  
| **Aspecto**       | **XP**                                  | **Agilidad General**          |  
|--------------------|-----------------------------------------|-------------------------------|  
| **Tácticas**       | Programación en pares, refactorización, iteraciones semanales. | Scrum, Kanban, menos prescriptivo. |  
| **Fortalezas**     | Ideal para **equipos pequeños** y requisitos muy cambiantes. | Más adaptable a distintos contextos. |  
| **Debilidades**    | **No escala bien** en proyectos largos/complejos. | Riesgo de caos sin experiencia. |  

**Conclusión**:  
- XP es útil en contextos específicos, pero **no es una solución universal**.  


#### **2.3 Criterios para Elegir Métodos**  
**Diagrama "Dimensions Affecting Method Selection"**:  
```  
┌──────────────────────────────────────┐  
│  ¿Ágil o Planificado? Factores:      │  
├──────────────────┬───────────────────┤  
| **Ágil**         | **Planificado**   |  
| - Equipos < 10   | - Equipos grandes |  
| - Requisitos     | - Requisitos      |  
|  muy dinámicos   |  estables         |  
| - Baja criticidad| - Alta criticidad |  
|  (ej.: app web)  |  (ej.: software médico) |  
└──────────────────┴───────────────────┘  
```  

**Factores clave**:  
1. **Personal**: ¿El equipo es experimentado? → Ágil requiere madurez.  
2. **Dinamismo**: ¿Los requisitos cambian semanalmente? → Ágil gana.  
3. **Criticidad**: ¿Un error puede costar vidas? → Planificado (ej.: aviación).  

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXf3oyKoBGRfK7BNU6GGgNv-GSL1acDnaacO-mz_ytWldTYCKIcyYvV3CVhSU85v9A5xMNbcTMwHDt5sZ228gZUWmeOqis82C6XmrB2pT_hvVvEWg5pTjG2CRsCRPIeaLnJX9edNaQ?key=t-HZ5X6NeHrPsfDXhr6b2sRB)

---

### **Esquema Visual para la Exposición**  
```  
┌──────────────────────────────┐  
│  AGILIDAD ≠ AUSENCIA DE PLAN │  
├──────────────────────────────┤  
│ 1. **Objetivos claros**:     │  
│    - Requisitos prioritarios │  
│ 2. **Equipos disciplinados**:│  
│    - XP: Pares, pruebas      │  
│ 3. **Mantenimiento realista**: │  
│    - 60-80% del esfuerzo     │  
└──────────────────────────────┘  
```  

#### **Consejos para Exponer**:  
1. **Ejemplo cotidiano**: Comparar un startup (ágil) vs. un banco (planificado).  
2. **Dato clave**: El 47% de los proyectos ágiles fallan por falta de claridad en requisitos (Standish Group).  
3. **Mensaje final**: La agilidad es una **herramienta**, no un dogma. Su éxito depende del contexto.  

---
### **3. Ingeniería de SW Basada en el Valor**  
*(Enfoque ágil que prioriza el valor para el usuario y la adaptabilidad sobre procesos rígidos)*  

#### **3.1 Adaptar la tecnología a usuarios**  
- **Objetivo**: Crear software que se ajuste a las necesidades humanas, no al revés.  
- **Claves**:  
  - Los usuarios/organizaciones prefieren **usabilidad** y **valor añadido** (ej.: interfaz intuitiva) antes que costos bajos o tecnicismos.  
  - Métodos ágiles: Desarrollan el software en **pequeños incrementos** priorizados por valor (ej.: funcionalidades más útiles primero).  

#### **3.2 Requisitos Emergentes (IKIWISI)**  
- **Problema**: Los usuarios no siempre saben qué necesitan hasta que lo prueban (*"lo sabré cuando lo vea"*).  
- **Solución**:  
  - **Experimentación constante**: Prototipos rápidos y ajustes basados en feedback.  
  - **Jerarquía de Jordan** (adaptación de Maslow para SW):  
    1. **Funcionalidad**: Resuelve un problema.  
    2. **Usabilidad**: Fácil, seguro y cómodo.  
    3. **Placer**: Beneficios emocionales (ej.: diseño atractivo).  

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeRw7tC7lzRxwzhkp5mxIQjO73jlcnjOW-uwPh1JK9Vhrag2sXhqHoAaE8FX39g97OGEp59sfZaSBhv-N1y2SJ04kqHLqD-OvWkxYR7CQ_VWrq9xTEDIURE3faz8pScfQTyDKYOGg?key=t-HZ5X6NeHrPsfDXhr6b2sRB)

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXelYU5qdhs8roIO1C-vxUrbmFwnxs6kz_v_l1jcj9f_TxDdOnm2IlMeXbRpJ61HgJ2-WNTfo_3BR-d17Fc57eeVfZDI1cMlRO7-NgueS0ph5V4O56fOF8UoVe-w5zna9SqDOjneRw?key=t-HZ5X6NeHrPsfDXhr6b2sRB)
#### **3.3 Incompatibilidad con métodos tradicionales**  
- **Ejemplo**: Modelo en cascada (etapas fijas) falla porque **congela requisitos** en un entorno cambiante.  
- **Alternativa**:  
  - **Enfoques situacionales**: Adaptarse al contexto (ej.: ágil para partes dinámicas, estructurado para requisitos legales).  

#### **3.4 Enfoque basado en valor**  
- **Regla clave**: Maximizar beneficio/minimizar riesgo.  
- **Estrategia**:  
  - **Ágil**: Para áreas con incertidumbre (ej.: nueva app móvil).  
  - **Estructurado**: Para partes críticas/estables (ej.: sistema bancario).  

### **Esquema Visual para la Exposición**  
```  
┌───────────────────────────────────┐  
│ Ingeniería Basada en Valor        │  
├─────────────────┬─────────────────┤  
│ Tradicional     │ Ágil            │  
│ (Rígido)        │ (Flexible)      │  
│ - Cascada       │ - Incrementos   │  
│ - Obsoleto      │ - IKIWISI       │  
└─────────────────┴─────────────────┘  
```  

**Consejo para exponer**: Usa ejemplos cotidianos (ej.: comparar Netflix, que evoluciona con feedback, vs. un DVD estático).


---

### **4. Criticidad y Confiabilidad del Software**  
*(¿Por qué la fiabilidad del software es crucial en la era digital?)*  

#### **4.1 La confiabilidad no era prioridad**  
- **Contexto histórico**:  
  - La industria TI privilegiaba **lanzamientos rápidos** sobre calidad (ej.: "mover rápido y romper cosas").  
  - **Caso Y2K (2000)**:  
    - **Fallo**: Sistemas críticos (bancos, hospitales) usaban 2 dígitos para años (ej.: "99" por 1999).  
    - **Consecuencia**: Corrección costó **$300 mil millones** y expuso la **dependencia global del software**.  

#### **4.2 Catástrofes que cambiaron el panorama**  
- **Eventos clave**:  
  1. **Apagón del Noreste de EE.UU. (2003)**: Fallo en software de gestión eléctrica dejó sin luz a 50 millones de personas.  
  2. **Boeing 737 MAX (2018-2019)**:  
     - **Error en el software MCAS** (sistema antiestancamiento) provocó 2 accidentes fatales.  
     - **Lección**: La falta de pruebas rigurosas en software crítico puede costar vidas.  

- **Impacto**:  
  - Aumento de **regulaciones estrictas** (ej.: normativas aeronáuticas, sanitarias).  
  - **Paradigma actual**: La confiabilidad es una **necesidad**, no un lujo.  


### **Esquema Visual para la Exposición**  
```  
┌───────────────────────────────┐  
│  Software No Confiable =      │  
│  Bomba de Tiempo              │  
├───────────────────────────────┤  
│ 1. **Económica**: Y2K ($300B) │  
│ 2. **Legal**: Multas/leyes    │  
│ 3. **Humana**: Muertes (737)  │  
└───────────────────────────────┘  
```  

#### **Consejos para exponer**:  
- **Ejemplo cotidiano**: Comparar un software médico con errores (riesgo de vida) vs. una app de redes sociales (puede permitirse bugs menores).  
- **Dato impactante**: "El costo de arreglar un error en producción es **100x mayor** que durante el desarrollo" (IBM Systems Sciences Institute).  
- **Mensaje final**: En sectores críticos (salud, transporte, energía), **la confiabilidad salva vidas y dinero**.  


### **5. COTS, Open Source y Software Heredado**  
*(Soluciones preconstruidas: ¿oportunidad o riesgo?)*  

#### **5.1 ¿Qué es COTS?**  
- **Definición**: Componentes comerciales listos para usar (*Commercial Off-The-Shelf*).  
  - **Ejemplos**: Windows, Oracle Database, SAP.  
- **Impacto**: Revolucionó el desarrollo al ofrecer soluciones instantáneas, pero con trade-offs.  

---

#### **5.2 Ventajas vs. Desventajas**  
| **Ventajas**                     | **Desventajas**                     |  
|-----------------------------------|-------------------------------------|  
| ✔ **Rapidez**: Implementación inmediata. | ✖ **Código cerrado**: Imposible modificar o auditar. |  
| ✔ **Costos bajos**: Reutilización masiva. | ✖ **Dependencia del vendedor**: Actualizaciones y soporte fuera de control. |  
| ✔ **Productividad**: LOCS (*Lines of Code in Service*) escalables como el hardware. | ✖ **Riesgo**: Obsolescencia o discontinuación. |  

---

#### **5.3 Impacto en la Industria**  
- **Cifras clave**:  
  - Uso de COTS pasó del **28%** (1997) al **70%** (2002) en aplicaciones críticas.  
- **Cambio en los roles**:  
  - Ingenieros ahora **integran/adaptan COTS** en lugar de codificar desde cero.  
  - Enfoque en **valor añadido** (ej.: personalización, experiencia de usuario).  

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXdFBK9EJtC_mACqMI8IC44LCPzTE_a5hrT34-NgoJlWXc2g95DPfZAShfcefrPboVc_fV-QsBCfWrx2Y2e0jWXA0nPcp7anNSZD04vv2ONW66q4a40IpnjJrR-bFGySTBhFpSzY?key=t-HZ5X6NeHrPsfDXhr6b2sRB)

#### **5.4 COTS vs. Open Source vs. Software Heredado**  
| **Criterio**       | **COTS**               | **Open Source**       | **Software Heredado** |  
|--------------------|------------------------|-----------------------|-----------------------|  
| **Flexibilidad**   | Baja (código cerrado)  | Alta (código abierto) | Variable (depende del legado) |  
| **Soporte**        | Depende del vendedor   | Comunidad o contratos | Interno o obsoleto    |  
| **Interoperabilidad** | Limitada           | Alta (estándares abiertos) | Riesgo de obsolescencia |  
| **Ejemplo**        | Microsoft Office       | Linux, Apache        | Sistemas bancarios antiguos |  

---

#### **5.5 Problemas Comunes y Futuro**  
- **Desafíos de COTS**:  
  - Usabilidad deficiente, falta de adaptabilidad, errores ocultos.  
- **Tendencias**:  
  - Presión de clientes está mejorando **fiabilidad** y **interoperabilidad**.  
  - Ejemplo: Empresas exigen APIs abiertas en COTS para integraciones.  

---

### **Esquema Visual para la Exposición**  
```  
┌──────────────────────────────────┐  
│    ¿Cuándo usar cada opción?     │  
├────────────────┬─────────────────┤  
│ **COTS**       │ **Open Source** │  
│ - Urgencia     │ - Control total │  
│ - Recursos limitados │ - Personalización │  
└────────────────┴─────────────────┘  
```  

#### **Consejos para la Exposición**:  
1. **Ejemplo cotidiano**: Comparar comprar un coche (COTS) vs. armarlo pieza por pieza (open source).  
2. **Dato clave**: "El **90%** de las empresas usan COTS, pero el **45%** reportan problemas de compatibilidad" (Gartner).  
3. **Mensaje final**: COTS acelera el desarrollo, pero requiere gestión de riesgos. El open source y el legado son alternativas, pero con sus propios desafíos.  


---

### **6. Desarrollo Impulsado por Modelos (MDD)**  
*(Construir software a partir de modelos abstractos para mayor flexibilidad y adaptabilidad)*  

#### **6.1 Arquitecturas Empresariales y COTS**  
- **Objetivo**: Integrar sistemas complejos (ej.: cadenas de suministro) mediante **protocolos estandarizados**.  
- **Caso real**: **Walmart** usó MDD para optimizar su logística, definiendo interfaces entre COTS y sistemas propietarios.  

#### **6.2 ¿Qué es el MDD?**  
- **Definición**: Método que usa **modelos abstractos** (diagramas, especificaciones) para guiar el desarrollo.  
- **Ventajas**:  
  - **Alta cohesión/bajo acoplamiento**: Componentes independientes pero integrados.  
  - **Adaptabilidad**: Los modelos se ajustan a cambios en requisitos o tecnología.  
- **Funciones clave**:  
  - Ingeniería de requisitos, diseño, documentación.  

#### **6.3 Desafíos y Soluciones en MDD**  
**Problema central**: ¿Cómo gestionar cambios en infraestructura o reglas de negocio?  

| **Solución**                     | **Mecanismo**                                           | **Herramienta clave**                    | **Beneficio**                           |     |
| -------------------------------- | ------------------------------------------------------- | ---------------------------------------- | --------------------------------------- | --- |
| **Modelos Orientados a Objetos** | Modularización y reutilización (ej.: clases, herencia). | **UML** (lenguaje unificado de modelado) | Facilita mantenimiento y escalabilidad. |     |
| **Arquitecturas SOA**            | Sistemas como **servicios independientes** (ej.: APIs). | Estándares como **SOAP**/**REST**        | Interoperabilidad entre tecnologías.    |     |

- **Ejemplo SOA**:  
  - **Solicitante**: App de pedidos.  
  - **Registro**: Directorio de servicios (ej.: catálogo de productos).  
  - **Proveedor**: Servicio de pago (con interfaz definida).  

---

### **Esquema Visual para la Exposición**  
```  
┌──────────────────────────────────────┐  
│  Desarrollo Impulsado por Modelos    │  
├──────────────────┬───────────────────┤  
│ **Abstracción**  │ **Implementación**│  
│ - Modelos UML    │ - Código generado │  
│ - SOA (servicios)│ - COTS integrados │  
└──────────────────┴───────────────────┘  
```  

#### **Consejos para la Exposición**:  
1. **Ejemplo cotidiano**: Comparar MDD con planos de arquitectura (modelos) vs. construir una casa (implementación).  
2. **Dato clave**: Empresas que usan MDD reducen **30%** el tiempo de desarrollo (IBM).  
3. **Mensaje final**: MDD y SOA son clave para sistemas escalables en entornos cambiantes, pero requieren expertise en modelado.  



